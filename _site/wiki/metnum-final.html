<!DOCTYPE html>
	<html lang="en">
		<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23d8eaeb%22></rect><text x=%2250%%22 y=%2250%%22 dominant-baseline=%22central%22 text-anchor=%22middle%22 font-size=%2293%22>🌳</text></svg>" />
            <title>Metodos Numericos - Notas para el final</title>
			<link rel="canonical" href="https://strikingloo.github.io/wiki/metnum-final">
			  <meta name="description" content="Notas para el final de MetNum. Basadas en el apunte de Frizo y adornadas con fragmentos del Burden. In Spanish.">
  			<meta property="og:site_name" content="Metodos Numericos - Notas para el final">

        	
        	<link rel="stylesheet" type="text/css" href="/css/post-min.css">
        	

			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52642322-5"></script>

			<script>
			  window.dataLayer = window.dataLayer || [];
			  function gtag(){dataLayer.push(arguments);}
			  gtag('js', new Date());

			  gtag('config', 'UA-52642322-5');
			</script>
			
			  <meta property="og:description" content="Notas para el final de MetNum. Basadas en el apunte de Frizo y adornadas con fragmentos del Burden. In Spanish.">
			
	  		<meta property="og:locale" content="en_US">
	  		
			  <meta property="og:title" content="Metodos Numericos - Notas para el final">
			  <meta property="og:type" content="article">
		  	  <meta property="article:published_time" content="2020-12-14T00:00:00-03:00">
		      <meta property="article:author" content="http://localhost:4000/">
		  	
		  	
  				<meta property="og:url" content="https://strikingloo.github.io/wiki/metnum-final">
  			
  			<meta content="index,follow" name="robots"><!-- All Search Engines -->
  			<meta content="index,follow" name="googlebot"><!-- Google Specific -->
  			<meta name="robots" content="max-image-preview:large">

		</head>
		<body>
			<div class="head-banner">
			<p>Strikingloo</p>
			<nav>
	    		<ul>
	        		<li><a href="/">Home</a></li>
		        	<li><a href="/about/">About</a></li>
	        		<li><a href="/wiki/">Wiki</a></li>
	        		<li><a href="/blog/">Blog </a></li>
	    		</ul>
			</nav>
			<div style="clear: both;"></div>
		    </div>

			<div class="container">
			
			<h1>Metodos Numericos - Notas para el final</h1>
<p class="meta">14 Dec 2020 - importance:  </p>




<div class="post">
  <h3 id="eliminacion-gaussiana">Eliminacion Gaussiana</h3>

<p>La eliminación Gaussiana convierte a una matriz en otra que representa ecuaciones con el mismo conjunto de soluciones, pero triangular superior (para que resolverla solo requiera forward substitution).</p>

<p>Lleva O(n^3) y se hace como lo hacemos a mano.</p>

<h3 id="condición-de-una-matriz--error-numérico-">Condición de una matriz -error numérico-</h3>

<p>En una matriz mal condicionada, un pequeño error en el resultado de una ecuación, genera una solución muy mala.</p>

<p>A x = b,</p>

<p>pero yo tengo que</p>

<p>A x = ~b, y resulta que aunque 
||~b - b|| &lt; \epsilon,
 ~x muy lejos de x.</p>

<p>Error hacia adelante: el error en x.</p>

<p>Error hacia atras: el error en b.</p>

<p>Tipicamente partimos de un error hacia atras, y eso nos genera un error hacia adelante (la veniamos cagando y eso promueve cagadas futuras).</p>

<p><img src="image/Screen_Shot_2020-12-11_at_21-30-42.png" alt="" loading="lazy" /></p>

<p>Numero de condición de la matriz</p>

<p><img src="image/Screen_Shot_2020-12-12_at_17-33-38.png" alt="" loading="lazy" /></p>

<p>Si A es <strong>simetrica, inversible y tiene LU</strong>, entonces <strong>tiene LDL</strong>.</p>

<h3 id="descomposición-de-cholesky">Descomposición de Cholesky:</h3>

<p><img src="image/Screen_Shot_2020-12-12_at_17-26-16.png" alt="" loading="lazy" /></p>

<p><strong>L es triangular inferior</strong> con positivos en la diagonal (no necesariamente 1).</p>

<p>A tiene <strong>Cholesky</strong> &lt;-&gt; A es <strong>simétrica definida positiva</strong>.</p>

<p>A es <strong>definida positiva</strong> si</p>

<p><img src="image/Screen_Shot_2020-12-12_at_17-27-26.png" alt="" loading="lazy" /></p>

<p>para todo x.</p>

<p>A definida positiva -&gt; su diagonal es toda positiva, y A inversible.</p>

<h3 id="descomposición-qr">Descomposición QR</h3>

<p>A = QR tq Q ortogonal, R triangular superior.</p>

<p>Toda matriz tiene QR.</p>

<p>Q ortogonal -&gt; Q^-1 = Q^t.</p>

<p>Q1, Q2 ortogonales -&gt; Q1Q2 = Q3 ortogonal.</p>

<p>Es única para inversibles, si pedimos R diagonal positiva.</p>

<p>Si tenemos una ecuación  Ax = b, podemos hacerla QRx=b.</p>

<p>De ahi podemos ir a Rx = Q^tb, y Q es numericamente muy estable y R es triangular.</p>

<p>Las matrices ortogonales conservan la norma 2 de los vectores.</p>

<h3 id="householder">HouseHolder:</h3>

<p>Si quiero hacer una serie de transformaciones ortogonales tal que al final me quede una matriz triangular superior, puedo llenar de 0s todo debajo de la diagonal para una columna iterativamente en cada paso.</p>

<p>Para hacer esto, uso reflexiones: muevo el vector de la columna de diagonal hacia abajo, hacia un vector de misma norma, pero con un solo componente no nulo (el primero, que corresponderia a la diagonal de la matriz anterior).</p>

<p>Si tengo el vector ortogonal al hiperplano en el que hago la reflexion, mi matriz ortogonal para esta transformación será:</p>

<p><img src="image/Screen_Shot_2020-12-12_at_18-18-24.png" alt="" loading="lazy" /></p>

<p>Pero cómo obtengo u? Simplemente parto de un vector que quiero que se refleje a otro. Sean v que quiero reflejar en w, obtengo u:</p>

<p><img src="image/Screen_Shot_2020-12-12_at_18-18-34.png" alt="" loading="lazy" /></p>

<p>Luego si tengo mi columna, como la quiero mappear conservando la norma, mis v y w serán:</p>

<p><img src="image/Screen_Shot_2020-12-12_at_18-18-52.png" alt="" loading="lazy" /></p>

<p>Y repito esto iterativamente. No ahorro complejidad pero tengo mas estabilidad numérica.</p>

<h3 id="transformación-de-givens">Transformación de Givens</h3>

<p>Puedo hacer rotar un vector por un ángulo theta. Con un vector de R^2 eso me permite llevarlo a un vector con un 0 en la segunda componente.</p>

<p><img src="image/Screen_Shot_2020-12-12_at_18-28-33.png" alt="" loading="lazy" /></p>

<p><img src="image/Screen_Shot_2020-12-12_at_18-28-49.png" alt="" loading="lazy" /></p>

<p>Esto generaliza a R^mxn, pero tengo que por cada columna, hacer una rotación por cada 0 que quiero agregar, así que son potencialmente O(n^2) rotaciones. La rotación se hace mirando los 2 componentes que querés rotar, y completando con la identidad en todos los otros.</p>

<p>La complejidad termina siendo la misma que con HouseHolder, pero con un factor constante mayor (4/3 vs 2/3), pero al ir 0 por 0 es muy eficiente en matrices ralas -información que HouseHolder no aprovecha-.</p>

<h3 id="svd---singular-value-decomposition">SVD - Singular Value Decomposition</h3>

<p>Descompongo a A tq:</p>

<p><img src="image/Screen_Shot_2020-12-12_at_19-00-21.png" alt="" loading="lazy" /></p>

<p>Donde</p>

<p><img src="image/Screen_Shot_2020-12-12_at_19-02-45.png" alt="" loading="lazy" /></p>

<p>Toda matriz tiene SVD.</p>

<p>Para generarla, tengo que computar A^t * A.</p>

<p>Los PC (sigma_i) son las raíces cuadradas de los eigenvalues de A^t * A (que son todos no negativos por ser A^t * A semi definida positiva).</p>

<p>Los vectores de V son los eigenvectors -de norma 1-.</p>

<p>Los vectores de U salen por esta ecuación:</p>

<p><img src="image/Screen_Shot_2020-12-12_at_19-22-51.png" alt="" loading="lazy" /></p>

<p>Si la matriz no era cuadrada, U_i para i &gt; r, se definen para hacer una base ortonormal de Nul(A^t). Asi cumplimos todas las propiedades.</p>

<h2 id="resolución-iterativa-de-ecuaciones-lineales">Resolución iterativa de ecuaciones lineales.</h2>

<h3 id="método-de-jacobi">Método de Jacobi</h3>

<p><img src="image/Screen_Shot_2020-12-13_at_21-08-10.png" alt="Screen_Shot_2020-12-13_at_21-08-10.png" loading="lazy" /></p>

<p><img src="image/Screen_Shot_2020-12-13_at_21-07-55.png" alt="" loading="lazy" /></p>

<p>Podemos garantizar que converge para matrices edd.</p>

<p>Para funcionar, A no puede tener 0s en la diagonal.</p>

<h3 id="método-de-gauss---seidel">Método de Gauss - Seidel</h3>

<p>Igual que el de Jacobi, pero usamos los valores que ya computamos para los primeros k componentes de x en vez de los de la x anterior.</p>

<p><img src="image/Screen_Shot_2020-12-13_at_21-07-46.png" alt="Screen_Shot_2020-12-13_at_21-07-46.png" loading="lazy" /></p>

<p>Podemos garantizar que converge para matrices sdp, y además converge más rápido que Jacobi.</p>

<h2 id="autovalores">Autovalores</h2>

<p>Para el método de la potencia, multiplicamos un vector inicial aleatorio x_0 por A repetidas veces hasta convergencia.</p>

<p><img src="image/Screen_Shot_2020-12-13_at_21-13-19.png" alt="" loading="lazy" /></p>

<p>El ratio entre el vector obtenido x, y Ax, en normas será el módulo del autovalor de módulo mas alto en la matriz. Al restar \mu* u u^t (producto externo) para mu el autovalor y u el autovector, obtenemos una nueva matriz cuyo autovalor de módulo mas alto ya no es el mismo.</p>

<h2 id="interpolación">Interpolación</h2>

<p>Tengo un conjunto de puntos, quiero hallar una función que pase por todos ellos y tenga ciertas propiedades deseables.</p>

<p>Tipicamente usamos un polinomio, o varios juntos, porque son bonitos, derivables y computables facilmente, y en general muy estudiados.</p>

<h3 id="polinomio-interpolador-de-lagrange">Polinomio interpolador de Lagrange</h3>

<p>Defino un polinomio que toma los valores de los puntos en los x correctos.</p>

<p><img src="image/Screen_Shot_2020-12-13_at_22-38-45.png" alt="Screen_Shot_2020-12-13_at_22-38-45.png" loading="lazy" /></p>

<p>Ademas, podemos acotar el error de la interpolación si tenemos una idea de la n+1-ésima derivada de la función (imagino que es difícil de obtener en la práctica), evaluandola en algun punto E entre [x0, xn].</p>

<p><img src="image/Screen_Shot_2020-12-13_at_22-38-54.png" alt="" loading="lazy" /></p>

<p>El polinomio de Lagrange es el único polinomio de grado n-1 que interpola estos n puntos.</p>

<h3 id="diferencias-divididas">Diferencias divididas</h3>

<p>Con diferencias divididas puedo computar un polinomio de Lagrange de forma recursiva para n puntos desde los anteriores n-1, en tiempo lineal. Esto permite agrandar el polinomio para ir fitteando mas puntos a medida que surgen.</p>

<p><img src="image/Screen_Shot_2020-12-13_at_22-43-25.png" alt="" loading="lazy" /></p>

<p>También se le dice método de Newton.</p>

<p>El método de Newton es el de diferencias divididas.</p>

<h3 id="método-de-neville">Método de Neville</h3>

<p><img src="image/Screen_Shot_2020-12-13_at_22-44-51.png" alt="" loading="lazy" /></p>

<p>Otra escritura recursiva del polinomio de Lagrange. Igual me hace computar n polinomios anteriores.</p>

<h3 id="interpolación-fragmentaria">Interpolación fragmentaria</h3>

<p>Interpolo entre dos puntos consecutivos usando un polinomio, pero la funcion total está “partida” concatenando varios polinomios de grado bajo. Esto previene el overfitting y la inestabilidad numérica, especialmente si tengo muchos puntos.</p>
<ul>
  <li><strong>Interpolación fragmentaria lineal</strong>: entre dos puntos consecutivos interpolo con una recta (de Lagrange). Solo garantiza interpolar, y es no derivable.</li>
  <li><strong>Interpolación fragmentaria cuadrática</strong>: hago lo mismo pero interpolo con una cuadrática en cada sección. Esto me permite garantizar que sea derivable en todos los puntos de “choque” de cuadráticas, además de interpolar correctamente.</li>
  <li><strong>Interpolación fragmentaria con splines cúbicos</strong>: interpolo entre los puntos con funciones cúbicas. Esto me permite, dada la cantidad de ecuaciones vs variables que tengo, pedir que en cada union de secciones coincidan en valor, derivada y segunda derivada. Esto hace que sea derivable y dos veces derivable en todos los puntos.</li>
</ul>

<h2 id="ceros-de-funciones">Ceros de funciones</h2>

<p>Buscamos generar una sucesión que converja a x*, tq h(x*) = 0.</p>

<p>Si mi ecuación tiene la pinta f(x) = g(x) , entonces defino h(x) = g(x) - f(x), y el 0 de h es la solución de g.</p>

<h3 id="orden-de-convergencia">Orden de convergencia</h3>

<p>Una sucesión que converge a <em>x*</em> tiene orden de convergencia <em>p</em> si se cumple la ecuación:</p>

<p><img src="image/Screen_Shot_2020-12-14_at_20-17-40.png" alt="" loading="lazy" /></p>

<p>Si para casi todo k, una sucesión Ai está más cerca de su límite A, que una Bi de su límite B, decimos que Ai converge al menos tan rápido como Bi.</p>

<h3 id="criterios-de-parada">Criterios de parada</h3>

<ul>
  <li>Parar luego de <strong>N iteraciones</strong>, regardless of results.</li>
  <li>Parar cuando la <strong>diferencia absoluta entre dos términos</strong> consecutivos es &lt; \epsilon.</li>
  <li>Parar cuando la <strong>diferencia relativa entre dos terminos</strong> es &lt; \epsilon.</li>
  <li>Parar cuando la función tome un valor menor a epsilon -<strong>f(x) &lt; ε</strong>- (por cercanía al 0).</li>
  <li>Parar cuando la <strong>diferencia relativa o absoluta entre dos valores de f</strong> sea &lt; ε.</li>
</ul>

<p>En la práctica lo mejor es definir criterios según cuál es el problema que tenemos.</p>

<h3 id="método-de-bisección">Método de bisección</h3>

<p><em>Basado en el teorema de Bolzano</em>.</p>

<p>Comienzo con un intervalo [a,b] en el que sé que f(a) * f(b) &lt; 0. Osea, un extremo positivo y otro negativo, sin mirar orden.</p>

<p>Necesariamente en el medio la función pasa por el 0 (si es continua).</p>

<p>Entonces</p>

<ul>
  <li>Parto el intervalo a la mitad.</li>
  <li>Miro cual de los dos intervalos resultantes cumple la misma propiedad.</li>
  <li>Repetir hasta convergencia.</li>
</ul>

<p>Converge linealmente.</p>

<h3 id="punto-fijo">Punto Fijo</h3>

<p>Dada una funcion g, x tq g(x) = x es un punto fijo de g. Luego para hallar un x tal, es facil si simplemente itero haciendo x := g(x) una y otra vez, partiendo de un x0 aleatorio.</p>

<h3 id="metodo-de-newton">Metodo de Newton</h3>

<p>Se basa en iteración de punto fijo.</p>

<p>Tengo que poder calcular f y f’ en un intervalo [a,b].</p>

<p>En particular hallo un punto fijo de la función</p>

<p><img src="image/Screen_Shot_2020-12-14_at_21-11-33.png" alt="" loading="lazy" /></p>

<p>Usando el método del punto fijo, mi iteración es simplemente:</p>

<p><img src="image/Screen_Shot_2020-12-14_at_21-11-40.png" alt="" loading="lazy" /></p>

<p>Es importante que g esté bien definida en un entorno de x*. Esto es, <strong>f’ no puede ser 0 en x*.</strong></p>

<p>La convergencia es cuadrática, pero solo en un entorno de x*. Por esto, se suele inicializar el algoritmo en un buen lugar con un par de iteraciones del metodo de la bisección, ya que necesitamos <strong>comenzar cerca de una aproximación relativamente buena de la raiz</strong>.</p>

<p>El otro problema es cómo computar la derivada de f, que puede ser computacionalmente costoso o directamente inviable.</p>

<h3 id="método-de-la-secante">Método de la secante</h3>

<p>Similar al de Newton, pero en vez de computar la derivada la aproximo como el cociente entre los dos ultimos valores de y, y los ultimos dos de x.</p>

<p>Los problemas son: resta de valores cada vez más cercanos puede ser numéricamente catastrófica. Convergencia un poco más lenta (de orden fi) que el método de Newton.</p>

<h3 id="regula-falsi">Regula Falsi</h3>

<p>Muy similar al método de bisección, pero en cada punto en vez de elegir como punto medio el promedio de a y b, usa el cero de la recta secante entre los extremos (a,f(a)) y (b, f(b)).</p>

<p>Converge linealmente igual que la bisección, pero en la práctica es más rápido, y evita la cancelación catastrófica del método de la secante.</p>

<h2 id="cuadrados-mínimos-lineales">Cuadrados Mínimos Lineales</h2>

<p>Tengo A x = b, y quiero hallar el x que minimiza el error cuadrático || b - Ax ||^2</p>

<p>Puedo usar 3 métodos:</p>

<h3 id="ecuaciones-normales">Ecuaciones normales</h3>

<p>Comienzo multiplicando a ambos lados por A^t por izquierda.
Puede verse que esto proyecta b al espacio vectorial generado por A (osea, elimina la parte ortogonal de b). A esto se lo llama que</p>

<p><em>“A^t * b es la proyección en la imagen de A de b”</em>.</p>

<p><img src="image/ata.png" alt="" loading="lazy" /></p>

<p>El sistema permite usar Cholesky, porque A^t*A es una matriz sdp. Pero, la estabilidad numérica puede ser muy mala.</p>

<h3 id="resolución-por-factorizacion-qr">Resolución por Factorizacion QR</h3>

<p>Reescribo A = QR.</p>

<ul>
  <li>Si A es rango columna completo, luego solo tengo que resolver R1 = c, donde R1*x es la parte no nula de R, y c es los primeros rg(A) componentes de Q^t * b.</li>
  <li>Si no es rango columna completo, tenemos en cuenta el pivoteo.</li>
</ul>

<h3 id="resolución-svd">Resolución SVD</h3>

<p>Esta es la que mas se usa en la práctica: es más lenta, pero en casos de matrices de rango incompleto tiene mucha más estabilidad numérica.</p>

<p><img src="image/metnum_svd.png" alt="" loading="lazy" /></p>

<p>Aca una vez más separamos en casos:</p>

<p>Si A es rango columna completa, hay una forma cerrada para x:</p>

<p><img src="image/svd_sol_1.png" alt="" loading="lazy" /></p>

<p>Sino, la forma cerrada es esta:</p>

<p><img src="image/svd_sol_2.png" alt="" loading="lazy" /></p>

<p>Donde los y_k pueden ser cualquier real. Se suele usar que sean todos 0 para minimizar la norma.</p>

<h3 id="complejidades-computacionales">Complejidades Computacionales</h3>

<p>Factorizacion de Cholesky : O(n^3) -aunque mas rápida-</p>

<p>Factorizacion LU : O(n^3)</p>

<p>Eliminacion Gaussiana: O(n^3) -similar a LU-</p>

<p>Forward Substitution (en una triangular): O(n^2)</p>

<p>Factorización QR por HouseHolder: O(n^3)</p>

<p>Pero al ser QR es numericamente mas estable que otras.</p>

<p>1.2, 1.3, 2.1, 2.2, 2.3, 6.1, 6.2, 6.5</p>

<p>6.6 (cholesky y estrictamente diagonal dominante), 9.2 (método potencia), 3.1, 3.2, 3.4 (interpolación), 4.3, 4.4, 4.6 (integración), 7.3, 7.4, 7.5 (métodos iterativos)</p>


</div>
<a href='https://ko-fi.com/R6R3F4NIO' target='_blank' rel="noopener noreferrer nofollow">
  <img style='border:0px;height:4em;width:auto;' src='https://cdn.ko-fi.com/cdn/kofi5.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' loading='lazy'/></a>
  <p style='text-align: center;'>
  <a href="https://twitter.com/intent/tweet?text=Metodos Numericos - Notas para el final&url=https://strikingloo.github.io/wiki/metnum-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" title="Share on Twitter!">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em" rel="noopener noreferrer nofollow"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>Share on twitter]</a></p>

<template id="post-delayed-content">

<div class="backButton">
<a href="https://twitter.com/intent/tweet?text=Metodos Numericos - Notas para el final&url=https://strikingloo.github.io/wiki/metnum-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" id='tweetThis' title="Share on Twitter!" rel="noopener noreferrer nofollow">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>]</a>
<br/>
<a href="/blog/" id='backToBlog' title="Back to blog" rel="noopener noreferrer">[←]</a>
</div>
</template>
<script>
/*
const headings = document.querySelectorAll('h2[id],h3[id]');
for (var heading of headings) {
    heading.innerHTML = `<a href=#${heading.id}>${heading.innerHTML}</a>`;
}*/
function externalLinks() { for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) { var b = c[a]; b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank") } }
externalLinks();

function renderBottomButtons(){
  const templateNode = document.getElementById('post-delayed-content')
  const templateContentClone = templateNode.content.cloneNode(true) // perform a deep copy
  document.body.appendChild(templateContentClone)
}

function scrollEventHandler(){
 const scrollOffset = window.pageYOffset
 const browserViewHeight = window.innerHeight
 if (scrollOffset > browserViewHeight/3) {
    console.log('done')
    renderBottomButtons();
    window.removeEventListener('scroll', scrollEventHandler)
 }
}
window.addEventListener('scroll', scrollEventHandler)
</script>

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@StrikingLoo" />
<meta name="twitter:title" content="Metodos Numericos - Notas para el final" />
<meta name="twitter:description" content="Notas para el final de MetNum. Basadas en el apunte de Frizo y adornadas con fragmentos del Burden. In Spanish." />

<meta name="twitter:image:src" content="https://strikingloo.github.io/resources/book-tw.jpg"/>
<meta property="og:image" content="https://strikingloo.github.io/resources/preview-image-terrarium.png"/>

			
			</div>
			<footer>
	    		<ul>
	        		<li><a href="mailto:lucianostrika44@gmail.com" rel="me" title="email me">✉️</a></li>
	        		<li><a href="https://github.com/strikingloo" rel="me noopener noreferrer nofollow" title="GitHub"><svg viewBox="0 0 438.549 438.549" xmlns="http://www.w3.org/2000/svg" height="1em" width="1em"><path fill="#0F3D3E" d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289s4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136s11.704-.476 16.274-1.423c4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z"></path></svg></a></li>
			        <li><a href="https://twitter.com/intent/follow?screen_name=strikingloo" rel="me noopener noreferrer nofollow" title="twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg></a></li>
			        <li><a href="http://www.linkedin.com/in/luciano-strika" rel="me noopener noreferrer nofollow" title="linkedin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M72.16 99.73H9.927a5 5 0 00-5 5v199.928a5 5 0 005 5H72.16a5 5 0 005-5V104.73a5 5 0 00-5-5zM41.066.341C18.422.341 0 18.743 0 41.362 0 63.991 18.422 82.4 41.066 82.4c22.626 0 41.033-18.41 41.033-41.038C82.1 18.743 63.692.341 41.066.341zM230.454 94.761c-24.995 0-43.472 10.745-54.679 22.954V104.73a5 5 0 00-5-5h-59.599a5 5 0 00-5 5v199.928a5 5 0 005 5h62.097a5 5 0 005-5V205.74c0-33.333 9.054-46.319 32.29-46.319 25.306 0 27.317 20.818 27.317 48.034v97.204a5 5 0 005 5H305a5 5 0 005-5V194.995c0-49.565-9.451-100.234-79.546-100.234z"></path></svg></a></li>
			        <li><a href="/resources/Luciano_Strika.pdf">CV</a></li>
				</ul>
				<p><i>Built with ❤️ by <a href="https://strikingloo.github.io/">Strikingloo</a>.</i></p>
			</footer>
			

			

			
			<link rel="preload" href="/css/non-critical-post-min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
			<noscript><link rel="stylesheet" href="/css/non-critical-post-min.css"></noscript>
        	
		</body>
	</html>
