<!DOCTYPE html>
	<html lang="en">
		<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23d8eaeb%22></rect><text x=%2250%%22 y=%2250%%22 dominant-baseline=%22central%22 text-anchor=%22middle%22 font-size=%2293%22>üå≥</text></svg>" />
            <title>Teor√≠a de Lenguajes - Notas para el final</title>
			<link rel="canonical" href="https://strikingloo.github.io/wiki/tleng-final">
			  <meta name="description" content="Notas para el final de Tleng. Basadas en las te√≥ricas de la materia, y adornadas luego al leer las preguntas tipicas de final. In Spanish.">
  			<meta property="og:site_name" content="Teor√≠a de Lenguajes - Notas para el final">

        	
        	<link rel="stylesheet" type="text/css" href="/css/post-min.css">
        	

			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52642322-5"></script>

			<script>
			  window.dataLayer = window.dataLayer || [];
			  function gtag(){dataLayer.push(arguments);}
			  gtag('js', new Date());

			  gtag('config', 'UA-52642322-5');
			</script>
			
			  <meta property="og:description" content="Notas para el final de Tleng. Basadas en las te√≥ricas de la materia, y adornadas luego al leer las preguntas tipicas de final. In Spanish.">
			
	  		<meta property="og:locale" content="en_US">
	  		
			  <meta property="og:title" content="Teor√≠a de Lenguajes - Notas para el final">
			  <meta property="og:type" content="article">
		  	  <meta property="article:published_time" content="2021-07-21T00:00:00-03:00">
		      <meta property="article:author" content="http://localhost:4000/">
		  	
		  	
  				<meta property="og:url" content="https://strikingloo.github.io/wiki/tleng-final">
  			
  			<meta content="index,follow" name="robots"><!-- All Search Engines -->
  			<meta content="index,follow" name="googlebot"><!-- Google Specific -->
  			<meta name="robots" content="max-image-preview:large">

		</head>
		<body>
			<div class="head-banner">
			<p>Strikingloo</p>
			<nav>
	    		<ul>
	        		<li><a href="/">Home</a></li>
		        	<li><a href="/about/">About</a></li>
	        		<li><a href="/wiki/">Wiki</a></li>
	        		<li><a href="/blog/">Blog </a></li>
	    		</ul>
			</nav>
			<div style="clear: both;"></div>
		    </div>

			<div class="container">
			
			<h1>Teor√≠a de Lenguajes - Notas para el final</h1>
<p class="meta">21 Jul 2021 - importance: 8 </p>




<div class="post">
  <h2 id="definiciones">Definiciones</h2>

<p><img src="tleng-images/sc_grammar_type_3.png" alt="" />
<img src="tleng-images/sc_grammar_type_2.png" alt="" />
<img src="tleng-images/sc_grammar_type_1.png" alt="" />
<img src="tleng-images/sc_def_AFD.png" alt="" />
<img src="tleng-images/sc_def_AFD_cadena.png" alt="" /></p>

<h2 id="lema-de-pumping">Lema de Pumping</h2>

<p>Sii un lenguaje es finito (tiene finitas cadenas) todo automata que lo reconoce ser√° ac√≠clico.</p>

<p>Lema de pumping para regulares:</p>

<p>Existe n, para todo w, tq (w in L AND |w| &gt;= n) -&gt; Existe x,y,z tq</p>
<ul>
  <li>w = xyz</li>
  <li>|xy| &lt;= n</li>
  <li>|y| &lt;= 1</li>
  <li>Para todo i &gt;= 0, xy^iz in L.</li>
</ul>

<p>Osea existe algun n, tq para todo w en L de longitud al menos n, existe una manera de tomar los primeros hasta n caracteres, tq tomo un sufijo no vacio de ese prefijo, lo pumpeo i veces para i &gt;= 0, y siempre ese pumpeado esta en el lenguaje.</p>

<h2 id="equivalencias">Equivalencias</h2>

<p>Si tengo una <strong>gramatica regular</strong>, existe un <strong>AFND</strong> que genera el mismo lenguaje (es straightforward la conversion).</p>

<p>Si tengo un <strong>AFD</strong>, hay una <strong>gramatica regular</strong> equivalente.</p>

<p>Dada una <strong>expresion regular</strong> r, existe un <strong>AFND-l</strong> M tq #qf = 1, y L(M) = L(r).</p>

<p>Estas 3 se demuestran por induccion en la longitud de la cadena. En las primeras dos probamos la equivalencia entre As -&gt; wa y d(s, wa) = qf. 
En la tercera vamos por induccion en la longitud de la regex (cantidad de operadores) e induccion estructural.</p>

<p>Ademas, dado un <strong>AFD</strong> existe una <strong>regex</strong> que acepta el mismo lenguaje.</p>

<hr />

<h2 id="propiedades-de-lenguajes-regulares">Propiedades de lenguajes regulares</h2>

<blockquote>
  <p>Son cerrados en complemento, union e intersecci√≥n finitas (no infinitas, ver { a^kb^k¬†}).</p>
</blockquote>

<h3 id="problemas-decidibles-en-lenguajes-regulares">Problemas decidibles en lenguajes regulares</h3>
<ul>
  <li><strong>pertenencia</strong> (dado w, est√° en L?)</li>
  <li><strong>vacuidad</strong> (L = {}?)</li>
  <li><strong>finitud</strong> (#L)</li>
  <li><strong>equivalencia</strong> (se resuelve por diferencia de conjuntos, que es regular por lo visto mas arriba).</li>
</ul>

<h2 id="automatas-de-pila">Automatas de pila</h2>

<p><img src="tleng-images/sc_def_automata_de_pila.png" alt="" /></p>

<p>Aceptaci√≥n puede ser por estado final (si al terminar de procesar la cadena, llegu√© a un estado en F, acepto la cadena independientemente del contenido de la pila) o por pila vac√≠a (si al terminar de procesar la cadena la pila est√° vac√≠a, acepto independientemente de en qu√© estado estoy).</p>

<p>Para cualquier automata con aceptacion por estado final, podemos facilmente construir uno de aceptaci√≥n por pila vacia (en todos los estados finales ponemos transicion lambda a un nodo que simpemente desapila todos los elementos hasta vaciar la pila. Inicialmente pusheamos a la pila un caracter distinguido que el automata anterior nunca poppeaba, para evitar vaciar la pila en el medio por error).</p>

<p>Para el otro lado tambien es facil construir un automata de aceptacion por estado partiendo de uno de pila vacia: podemos agregar a todos los nodos una transici√≥n si la pila tiene un cierto simbolo distinguido agregado, que lleve a un nuevo nodo final adicionado. Luego al comienzo partimos de un q0‚Äô que pushea ese distinguido inicial, entonces corre todo el otro automata, deja la pila vacia salvo por el simbolo nuevo X0, y ahi salta por transici√≥n lambda a un Qf que lo poppea y termina.</p>

<p>Las gramaticas libres de contexto pueden modelarse con un automata de pila que acepte el lenguaje que genera. Puede pushear tanto Vn como Vt a la pila, el resto es intuitivo. Tiene un solo nodo q0.</p>

<p>‚ÄúSi en el tope de la pila hay un s√≠mbolo no-terminal t, el automata lo reemplazar√° por el lado derecho Œ± de alguna produccion del mismo de tal manera que el s√≠mbolo mas a la izquierda en el lado derecho de dicha produccion quede en el tope de la pila.</p>

<p>Si en el tope de la pila hay un s√≠mbolo terminal t, el automata constatara que es igual al pr√≥ximo s√≠mbolo en la cadena de entrada y lo desapilar√°. 
Este automata acepta L por pila vac√≠a.‚Äù</p>

<h3 id="automata-de-pila-deterministico">Automata de pila deterministico</h3>

<p><img src="tleng-images/sc_def_automata_de_pila_det.png" alt="" /></p>

<p>Tiene para cada tripla q, a, A de estado, caracter y tope de pila, como mucho una transici√≥n posible. Y en particular si tiene transici√≥n lambda para un estado y tope, entonces no tiene transici√≥n no-lambda.</p>

<p>Si un idioma no es libre de prefijos (x en L entonces xy no en L), entonces todo automata de pila M que acepta L necesariamente ser√° no-deterministico. (Sino, vacio la pila y termino, porque necesito aceptar x, y nunca podria aceptar xy).</p>

<h3 id="los-apd-se-tildan">Los APD se tildan?</h3>

<p>Un AFD o AFND-l no se puede tildar. En cambio:</p>

<p>La cantidad de transiciones que realiza un AP determin√≠stico no est√° acotada por el tama√±o de la entrada. La ejecuci√≥n depende no solamente de la entrada sino tambi√©n del contenido de la pila.</p>

<p>Es posible que un aut√≥mata de pila determin√≠stico realice una cantidad infinita de Œª-movimientos desde alguna configuraci√≥n. Decimos que estas configuraciones ciclan.</p>

<p>E.g., dos nodos que se vinculan mutuamente con lambda, uno pushea a si top ==b, el otro pushea b si top ==a.</p>

<p>Formalmente, una configuracion (q, w, Œ±) con |Œ±| &gt; 0 cicla si existen infinitas (qi, w, Œ±i) tq |Œ±i| &gt;= |Œ±|. Osea, infinitas transiciones lambda, que no achican la cadena ni los contenidos de la pila.</p>

<p>Notar que la pila podria crecer indefinidamente, o ciclar entre varias cadenas (e.g. arranca en a, y despues cicla entre abcd y acdb).</p>
<h2 id="gram√°ticas-libres-de-contexto">Gram√°ticas libres de contexto</h2>

<p>Una gramatica G es ambigua si para una cadena w, existen dos √°rboles de derivaci√≥n distintos.</p>

<p>Un lenguaje L independiente de contexto es <strong>intrinsecamente ambiguo</strong> si para toda G tq L(G) = L, G es ambigua.</p>

<p>Si una cadena w tiene un √°rbol de derivaci√≥n en G tq su altura = h, sea a = max( {|b| tq A -&gt; b in P} ), |w|&lt;= a^h.</p>

<p>Hay un pumping para indep de contexto.</p>

<p>Si L1, L2 son indep de contexto, tambi√©n lo son:</p>
<ul>
  <li>L1 U L2</li>
  <li>L1L2</li>
  <li>L1+</li>
</ul>

<p>Sin embargo L1 AND L2 no siempre ser√° indep de contexto.</p>

<p>Si L1 regular y L2 indep de contexto, entonces L1 AND L2 es indep de contexto.</p>

<p>L1 indep de contexto deterministico, entonces L1^c tambien. Si L1 no-det, entonces L1^c puede ser cualquier cosa.</p>

<p>Llamamos a w <strong>forma sentencial</strong> de G gram√°tica, si G -*&gt; w. Llamamos a A alcanzable en G si existe una forma sentencial que lo contiene. Llamamos a A activo si existe w tq A =*&gt; w.</p>

<p>Una gram√°tica G es reducida si todo no-terminal es alcanzable y activo. Decimos que una gram√°tica es propia si no tiene producciones borradoras (A -&gt; lambda).</p>

<p><strong>Forma Normal de Chomsky</strong>: si G es una gram√°tica y genera un lenguaje L indep de contexto que no contiene lambda, hay una G‚Äô cuyas todas producciones son de la pinta:</p>

<p><code class="language-plaintext highlighter-rouge">A -&gt; BC | a</code></p>

<p>Para A,B,C Vn y a Vt, tq L(G‚Äô) = L(G).</p>

<p><strong>Forma normal de Greibach</strong> : Dado un mismo lenguaje (indep de contexto, sin cadena vacia), existe una gramatica que lo genera tq todas sus prod tienen pinta:</p>

<p><code class="language-plaintext highlighter-rouge">A -&gt; a w</code></p>

<p>Tq w in Vn*, a in Vt.</p>

<p>Existe un lenguaje recursivo, que no es independiente del contexto.</p>

<p>El lenguaje aceptado por una maquina de Turing (que en cada transicion pasa de un estado a otro,y tiene una cinta en la que va leyendo un caracter, escribiendo otro y moviendose a izquierda o derecha a la vez que cambia de estado), es cualquier w tq q0w |-* w1 p w2 con p in F y w1, w2 cadenas de gamma.</p>

<p>Sea M una MT-no-deterministica. Existe una M deterministica que genera el mismo leguaje. Esto se logra probando a fuerza bruta cada una de las posibles combinaciones de transiciones: si cada nodo tiene maximo r salidas, entonces numeramoslas y generamos con eso una secuencia, que luego simulamos. Podemos hacer esto usando 3 cintas (o escribiendo todo en la segunda y leyendo y escribiendo mas adelante a la LyC).</p>

<p>Si G es gramatica sin restricciones, hay una MT que acepta L(G).</p>

<h2 id="gramaticas">Gramaticas</h2>

<p><strong>Tipo 0</strong>: Todas las gramaticas que generan lenguajes recursivamente enumerables (reconocibles por una turing machine, pero que puede devolver false o loopear cuando no pertenece). Son todas las gramaticas formales.</p>

<p><strong>Tipo 1</strong>: Lenguajes dependientes del contexto. Las reglas son w -&gt; v tq |w|&lt;=|v|. Todos los lenguajes generados por automatas linealmente acotados: m√°quinas de Turing deterministicas cuya cinta de memoria es acotada por un multiplo de la longitud de la entrada. (memoria lineal en el tama√±o de la entrada).</p>

<p>Reconocer una cadena de este lenguaje es PSPACE-complete.</p>

<p><strong>Tipo 2</strong>: Gram√°ticas independientes del contexto. Todas sus reglas son de forma A -&gt; w. A no terminal, w una cadena cualquiera. Generan todos los lenguajes aceptados por un aut√≥mata de pila.</p>

<p>Pueden ser lenguajes aceptados por un automata de pila determin√≠stico o no-determin√≠stico. Si pertenecen al primer tipo, pueden ser reconocidos en tiempo lineal en el tama√±o de la entrada, y se llaman lenguajes LR. Un subconjunto de los LR son los lenguajes LL (que tienen gramaticas LL). 
Por ultimo, los lenguajes libres de contexto no determin√≠sticos tienen un algoritmo que los reconoce en tiempo c√∫bico.</p>

<p><strong>Tipo 3</strong> : Gram√°ticas regulares. Las reglas son de la forma A -&gt; aB o A -&gt; a, con A, B no-terminales y a un terminal. Estas gram√°ticas generan todos los lenguajes aceptados por un automata determin√≠stico finito. Los llamamos lenguajes regulares. Pueden definirse por expresiones regulares.</p>

<p>Ver si una cadena pertenece o no a un lenguaje regular es lineal en el tama√±o de la entrada, usando un automata finito (vemos si la cadena termina llevando a un estado final o no).</p>

<blockquote>
  <p>El problema de decidir si una gram√°tica libre de contexto es ambigua no es decidible.</p>
</blockquote>

<p><strong>Lenguaje inherentemente ambiguo</strong>: Toda gram√°tica que lo genera es ambigua (tiene una cadena que tiene mas de una derivaci√≥n a izquierda).</p>

<p>Dada una gram√°tica ambigua, podemos intentar cambiar la gram√°tica, o descartar √°rboles de derivaci√≥n dando reglas de precedencia.</p>

<p><strong>Gram√°ticas recursivas a izquierda</strong> : Una gram√°tica es recursiva a izquierda si tiene un no-terminal A tq A =+&gt; Aw para w alguna cadena de terminales y no terminales. Puede ser inmediatamente recursiva a izquierda (e.g., tiene A -&gt; Ab) o no (A -&gt; Bc. B -&gt; Ad).</p>

<blockquote>
  <p>Todo lenguaje libre de contexto tiene una gram√°tica que no es recursiva a izquierda.</p>
</blockquote>

<p><strong>Gram√°tica sin ciclos</strong>: Una gram√°tica es libre de ciclos si no hay un no-terminal A tq A =*&gt; A.</p>

<p>En las libres de contexto, los ciclos surgen por A -&gt; lambda, o A -&gt; B tq B otro no-terminal. Pueden remediarse con algoritmos de eliminaci√≥n de la recursi√≥n.</p>

<p>Hay un algoritmo de eliminacion de la recursion a fuerza bruta (por cada simbolo no terminal, si tiene una produccion que empieza con otro no terminal, lo cambio por todas las producciones de ese otro y elimino esa - A -&gt; B, B -&gt; a entonces cambio por A -&gt; a). Pero esto en el peor escenario agrega (|P|/n)^n producciones nuevas, explotando exponencialmente.</p>

<h2 id="gramaticas-ll-y-lr">Gramaticas LL y LR</h2>

<p>Las gramaticas libres de contexto que generan lenguajes que pueden analizarse sintacticamente en manera deterministica en tiempo lineal en el tama√±o de la entrada, pueden ser LL o LR. Ambas se leen de izquierda a derecha, la primera usando leftmost derivation, la segunda rightmost derivation.</p>

<h3 id="gram√°ticas-ll">Gram√°ticas LL</h3>

<p>Una gram√°tica es LL si es LL(k) para algun k &gt;=1.</p>

<p>Las LL(k) son libres de contexto, no-ambiguas, para las cuales la derivaci√≥n m√°s a la izquierda est√° determinada por los simbolos ya leidos, y k simbolos mas.
El parsing es top-down, yendo de S a la cadena paso a paso de derivaci√≥n.</p>

<p>Si w in L(G) tq w = a1‚Ä¶an y S = w0 y w_m = w, wi -L&gt; wi+1, entonces la secuencia w0‚Ä¶wm es el parsing de w a izquierda.</p>

<p>Una gramatica LL(k) cumple wi = a1‚Ä¶ajAv entonces wi+1 es determinable conociendo a[1:j+k].</p>

<p>Dado w in (Vt U Vn)*</p>

<p>Primeros_k(w) = conjunto de prefijos de k caracteres de todas las cadenas de terminales que pueden formarse desde w  (w =*&gt; zv tq |z|&lt;=k).</p>

<p>Una gramatica LL(k) cumple que si tengo S =&gt; wAv =&gt; wuv =&gt; wx y S =&gt; wAv =&gt; wu‚Äôv =&gt; wy, y primeros_k(x) =primeros_k(y) entonces u==u‚Äô.</p>

<p>Osea: si tengo dos cadenas que empiezan igual, tienen a la mas izquierda al mismo no-terminal, y terminan en dos cadenas que comparten los primeros k caractres (+ el prefijo compartido) entonces ese mismo no-terminal tiene que haber mutado a la misma cadena en su derivaci√≥n mas a la izquierda.</p>

<blockquote>
  <p>Una gram√°tica G libre de contexto es LLk sii para todo wAv tq S =*&gt;L wAv y todo par de producciones A -&gt; u y A -&gt; u‚Äô, u!=u‚Äô, primeros_k(uv) AND primeros_k(u‚Äôv) == {}.</p>
</blockquote>

<p><img src="tleng-images/siguientes.png" alt="" /></p>

<p><strong>Simbolos directrices (SD)</strong> : SD(A -&gt; v) : primeros(v) si v no anulable; primeros(v) U siguientes(A) si v es anulable.</p>

<blockquote>
  <p>Una gram√°tica libre de contexto G es LL(1) sii para cada A, a hay a lo sumo una unica producci√≥n tq A -&gt; v y a in SD(A -&gt; v).</p>
</blockquote>

<p>Osea, por cada no-terminal A, puede tener una sola producci√≥n tq su SD sea cada caracter terminal.</p>

<p>Toda gramatica LL(1) <strong>no es recursiva a izquierda</strong>. Adem√°s, toda gram√°tica LL(k) es no-ambigua.</p>

<h2 id="gram√°ticas-lrk">Gram√°ticas LR(k)</h2>

<p>Las gram√°ticas LR(k), con k un n√∫mero entero mayor o igual que 0, son gram√°ticas libres de contexto no ambiguas para las cuales dada una expresi√≥n del lenguaje se puede encontrar su derivaci√≥n m√°s a la derecha de manera ‚Äúbottom-up‚Äù, de modo tal que en cada paso de la derivaci√≥n est√° determinada por los s√≠mbolos ya le√≠dos de la cadena de entrada y k s√≠mbolos m√°s.</p>

<p><strong>Definicion</strong>
<img src="tleng-images/LRk.png" alt="" /></p>

<p>LR(k) -&gt; LR(k+1). Lo opuesto no es cierto.</p>

<p>Toda gramatica LR es no ambigua. LL C LR.</p>

<p>Un lenguaje es <strong>reconocible con automata de pila deterministico sii es un lenguaje LR(1)</strong>.</p>

<p>Para toda gramatica LR(k), k &gt;= 0, G, hay una gram√°tica G‚Äô LR(1) tq L(G) = L(G‚Äô).</p>

<h2 id="parsing-ll1">Parsing LL(1)</h2>

<p>Para parsear un lenguaje LL(1) dada su gramatica G:</p>

<ul>
  <li>generamos la tabla LL(1): Esta tabla tiene Vn en filas, Vt en columnas, y M(A,a) = A -&gt; v tq SD(A -&gt; v) == a. Este elemento, si existe es unico, o el lenguaje no seria LL(1). Si no existe, dictar√° cadenas no aceptadas.</li>
  <li>Una vez hecha la tabla, tenemos una pila que arranca con $S y la cadena en una queue. Vamos desapilando de a un caracter y:</li>
  <li>Si es un No-terminal, miramos el frente de la queue y buscamos M(A,a). Luego apilamos en orden inverso el RHS de la produccion correspondiente.</li>
  <li>Si es un terminal, comparo con el tope de la queue. Si matchean, desencolo y desapilo. Si no matchean, raise ValueError().</li>
  <li>Repito hasta que tope de pila == $. Ahi devuelvo True.</li>
</ul>

<p>El runtime es O(n) donde n es |w| ya que por cada caracter de la cadena, a lo sumo pasamos L^k veces por transformaciones antes de matchearlo, donde L es el maximo size de una RHS de produccion, y k = |Vn|.</p>

<h2 id="parsing-lr1">Parsing LR(1)</h2>

<blockquote>
  <p>G es LR(k), k&gt;=0, Hay G‚Äô tq G‚Äô es LR(1) y L(G‚Äô) == L(G).</p>
</blockquote>

<blockquote>
  <p>Los lenguajes LR(1) son los reconocibles por automatas de pila deterministicos.</p>
</blockquote>

<p><strong>Reducci√≥n</strong> : Si Œ±Aw =&gt; Œ±Œ≤w, entonces decimos que Œ±Œ≤w puede ser reducida usando la producci√≥n (A -&gt; Œ≤) a Œ±Aw.</p>

<p><strong>Pivote</strong> : Si Œ±Aw =&gt; Œ±Œ≤w, el pivote es el par (A -&gt; Œ≤), |Œ±|+1. Te dice, dado auw, donde ubicarte y qu√© prod usar para revertir la ultima transformaci√≥n m√°s a la derecha.</p>

<blockquote>
  <p><em>La t√©cnica de parsing determinista ‚Äúbottom up‚Äù que opera linealmente consiste en identificar un√≠vocamente el pivote y hacer una reducci√≥n.</em></p>
</blockquote>

<p><strong>Prefijo viable</strong>: Si Œ±Aw =&gt; Œ±Œ≤w, todo prefijo de Œ±Œ≤ es un prefijo viable de la gram√°tica G. En general, un prefijo es viable si no va mas alla del extremo derecho del pivote. (que es UNICO por cadena, o no ser√≠a LR!).</p>

<p>El algoritmo de parsing es, dada una cadena:</p>

<ul>
  <li>Busco el pivote, hago reduccion. loop.</li>
</ul>

<p>En m√°s palabras: voy apilando caracteres a una pila y viendo, cada vez, por cada sufijo del contenido de la pila si es una RHS de una prod. Si lo es, es la prod que quiero y reduzco. Si no lo es, sigo apilando. Sigo reduciendo hasta volver a S‚Äô.</p>

<blockquote>
  <p>El conjunto de prefijos viables de una gram√°tica LR(k) es regular.</p>
</blockquote>

<p><strong>item</strong>: Un item de una gramatica LR(k) es una produccion, un . a la derecha y una cadena de terminales de longitud &lt;=k.</p>

<p><strong>Item v√°lido LR(k)</strong>: Fijemos una gram√°tica G = (N,T,P,S) libre de contexto. 
Supongamos A ‚Üí Œ±Œ≤ ‚àà P. Un item [A ‚Üí Œ±.Œ≤, u], con u ‚àà T* y |u| ‚â§ k, es un item LR(k) v√°lido para el prefijo viable Œ∑Œ±, si existe una derivaci√≥n a derecha tq</p>
<ul>
  <li>S =&gt; Œ∑Aw =&gt; Œ∑Œ±Œ≤w.</li>
  <li>u ‚àà primeros_k(w)</li>
</ul>

<p>Si el lenguaje es LR(0), obviamos la segunda condici√≥n. Notar que si voy moviendo el punto, tengo 1 prefijo viable por cada posicion, entonces para A -&gt; Œ±Œ≤ voy teniendo |Œ±Œ≤| prefijos viables por cada Œ∑.</p>

<p>Para parsear una cadena LR(1) primero construimos un AFND-lambda que acepta el lenguaje de <strong>prefijos viables</strong> de G. Este se comporta tq q0 = [S‚Äô -&gt; .S, $], y hacemos la clausura lambda (que es agregar todos los [A -&gt; .u, $] si S -&gt; A). Y despues d([A -&gt; Œ±.XŒ≤, u], X) = [A -&gt; Œ±X.Œ≤, u], pero ademas hacemos clausura lambda de ambos lados!</p>

<p>Este automata te genera los prefijos viables de G (todos los qi son finales).
(d(q0, g) = q = [A -&gt; Œ±.XŒ≤, u] =&gt; g = Œ∑Œ± un prefijo viable.</p>

<p>Para parsear agregamos un M‚Äô automata de prefijos viables, pero tambien una tabla de accion (desplazar q, reducir A -&gt; Œ≤, Aceptar, Error).</p>

<p>La tabla ACCION toma un estado y un terminal, y se define:</p>
<ul>
  <li>if [A -&gt; Œ±.aŒ≤, b] en qi, con a ‚àà T y IR(qi, a) = qj =&gt; ACCION(qi, a) = <em>desplazar qj</em>.</li>
  <li>if [A -&gt; Œ±., a] en qi y A != S‚Äô con a ‚àà T U {$} =&gt; ACCION(qi, a) = <em>Reducir A ‚Üí Œ±</em>.</li>
  <li>if [S‚Äô -&gt; S., $] en qi  =&gt; ACCION(qi, $) = <em>Aceptar</em>.</li>
  <li>Else: Accion(qi, $) = <strong>Error</strong>.</li>
</ul>

<p>El algoritmo de parsing LR(1) es :</p>
<ul>
  <li>Pila = q0, sea q estado en tope de pila y a el primer caracter apuntado del input (el pointer arranca en 0).</li>
  <li>Loop hasta Accion(q, a) in {Accept, Error}</li>
  <li>if [ACCION(q, a) = Desplazar p] : push a, push p, pointer++.</li>
  <li>if [ACCION(q, a) = Reducir A -&gt; Œ±] : pop |Œ±| times. Let p = tope de pila. push A, push IR(p, A) -como IR es d, esto solo settea el proximo estado!-. Print(A -&gt; Œ±).</li>
</ul>

<blockquote>
  <p>Para todo aut√≥mata de pila determin√≠stico, hay otro P‚Äô tq L(P) = L(P‚Äô) pero P‚Äô no tiene configuraciones que ciclen.</p>
</blockquote>

<p>El algoritmo tiene complejidad lineal en el tama√±o de entrada. Podemos asignar a una configuracion una funcion V(C) = |pila| + 2*(|w| - i) donde i es mi posicion actual de la cadena w input.</p>

<p>Luego cada transici√≥n o bien el valor baja 2 (porque comi√≥ un caracter de la cadena), o baja &gt;=1 si reduje, o mas. Entonces si mi input tiene n caracteres, mi peor escenario es pasar por como mucho 2*n configuraciones. Como las LR no son ambiguas (ergo no tienen ciclos), mi automata de pila no va a ciclar infinitamente (no hay derivacion a derecha arbitrariamente larga). Hay una cota a cuantas operaciones puede hacer el automata de pila antes de cambiar de configuracion, y eso lo multiplicamos por n y ganamos. Entonces es lineal.</p>

<h2 id="gramaticas-con-atributos">Gramaticas con Atributos</h2>

<p>Una gram√°tica de atributos es una tupla (G, A, V, R) donde G es una gramatica (libre de contexto, no ambigua, sin Vn no alcanzables), A conjunto de atributos (A(X) es el cjto de atributos de X en NUT), V los dominios de los valores y R el conjunto de reglas asociadas a una produccion+atributo.</p>

<p>Un atributo X.a es sintetizado si hay una producci√≥n p : X -&gt; Œ± y una regla para p donde ocurre X.a. Un atributo X.a es heredado si hay una producci√≥n p : Y -&gt; Œ±XŒ≤ y una regla para p donde ocurre X.a.</p>

<p>Start no puede tener heredados.</p>

<p>Dado el √°rbol de derivaci√≥n, el valor de un atributo sintetizado en un nodo se obtiene de los nodos hijos, y el valor de un atributo heredado en un nodo se obtiene del nodo padre o de los nodos hermanos.</p>

<p><strong>Semantica de una cadena</strong> : Dada una cadena Œ±, y una gramatica GA, el significado de Œ± en L(G) es el conjunto de valores de A(S). Esto es el conjunto de valores que toma el simbolo start S.</p>

<p>El orden de evaluaci√≥n, si existe, queda parcialmente determinado por las dependencias entre los atributos. Si hay dependencias circulares, la evaluaci√≥n podr√≠a no ser posible. Para esto construimos un <strong>grafo de dependencias</strong> de una <strong>produccion</strong> tq si una regla define a en funci√≥n de b, decimos Xi.b -&gt; Xi.a.</p>

<p>Llamamos <strong>arbol atribuido</strong> al arbol de derivaci√≥n con etiquetas para atributos de A.</p>

<p><strong>Grafo de dependencias</strong>: Para cada produccion p, damos un grafo DP(p) de dependencias. Luego el de un arbol atribuido se forma mediante la composici√≥n de grafos de dependencias DP(p) para todo p.</p>

<p><strong>Gram√°tica de Atributos Circular</strong>: una GA ser√° circular si su grafo de dependencias lo es.</p>

<p><strong>Gram√°tica bien definida</strong>: Una GA est√° bien definida si no tiene ninguna forma sentencial con atributos que dependan circularmente de si mismos.</p>

<p><strong>Orden topol√≥gico de un grafo</strong>: Todos los nodos aparecen exactamente una vez, y si (u, v) en G entonces u aparece antes que v. (Vamos de los source a los sink).</p>

<blockquote>
  <p>Una gram√°tica GA est√° bien definida si todo orden topol√≥gico de su grafo de dependencias es orden de evaluaci√≥n consistente con las dependencias.</p>
</blockquote>

<p><strong>GA Completa</strong>:</p>
<ul>
  <li>Para toda producci√≥n p, A -&gt; Œ±X√ü, todos los atributos heredados de X se definen en p.</li>
  <li>Para toda producci√≥n p, A -&gt; Œ±, todos los atributos sintetizados de A se definen en p.</li>
</ul>

<p>A fin de cuentas, completa sii todos los atributos heredados y sintetizados definibles se definen.</p>

<p>GA Completa AND DP(GA) aciclico -&gt; GA bien definida.</p>

<p>Para testear si GA tiene un grafo de dependencias ciclico:</p>
<ul>
  <li>Generamos G‚Äô</li>
  <li>Generamos sus producciones</li>
  <li>Vemos la admisibilidad de las producciones revisando el grafo de dependencias de G.</li>
  <li>Quitamos de G‚Äô las producciones inutiles (las que no generan terminales desde start)</li>
  <li>Si en G‚Äô hay una <strong>producci√≥n que es un arco admisible</strong>^^, contestar G es circular. Sino, contestar GA bien formada.</li>
</ul>

<p>Si GA es bien definida, podemos generar GA‚Äô tq todos sus atributos son sintetizados.</p>

<p>X ‚Üí Œ±tY Y ‚Üí Œ≤ZŒ≥</p>

<p><strong>Gramaticas s-atribuidas</strong>: Una gramatica s-atribuida no tiene atributos heredados, y el grafo de dependencias directas de cada prod p es ac√≠clico. Pueden evaluarse en un solo recorrido ascendente.</p>

<p><strong>Gram√°tica l-atribuida</strong>: 1-pass grammar. X -&gt; X1X2X3‚Ä¶Xn =&gt; si (Xi.a, Xj.b) en grafo de dependencias, i &lt; j. Y el grafo es ac√≠clico.</p>

<h2 id="ultimas-2-clases">Ultimas 2 clases</h2>

<ul>
  <li>Hay un algoritmo para pasar cualquier gram√°tica G libre de contexto a forma normal de Chomsky.</li>
</ul>

<p>Por cada producci√≥n de forma A -&gt; a o A -&gt; BC la dejo como est√°. Si es A -&gt; X1X2 tq X1 o X2 en T, genero A -&gt; X1‚ÄôX2‚Äô. Si A -&gt; X1‚Ä¶Xk la desenvuelvo:</p>
<ul>
  <li>A -&gt; X1‚Äô&lt;X2‚Ä¶Xk&gt;</li>
  <li>&lt;X2‚Ä¶Xk&gt; -&gt; X2‚Äô&lt;X3‚Ä¶Xk&gt;</li>
</ul>

<p>Finalmente, si Xi es un T entonces Xi‚Äô -&gt; Xi. Si Xi en Vn, reemplazo Xi‚Äô por Xi.</p>

<p>Notar que |N‚Äô| &lt;= |N| + |T| + l * |P| donde l es la m√°xima longitud de un RHS.</p>

<p>La cantidad de operaciones es lineal en P.</p>

<h3 id="cocke-younger-kasami-cyk">Cocke Younger-Kasami (CYK)</h3>

<p>Construyo tabla T tq Tij = {¬†A tq A =+&gt; ai‚Ä¶ai+j-1 }. Osea todos los no-terminales que derivan ai‚Ä¶ai+j-1. (La tabla se indefine si i+j-1 &gt; n).</p>

<p>Luego w en L(G) sii S en T1,n.</p>

<p>Para construir la tabla de CYK:</p>

<ul>
  <li>Partimos de G una gramatica en forma normal de Chomsky sin lambda producciones, y con w como cadena de input.</li>
</ul>

<p>Definimos ti, 1 = {A : A -&gt; ai en P}, para i in 1‚Ä¶n.</p>

<p>Una vez computados ti,j‚Äô para i en 1‚Ä¶n y j‚Äô en 1‚Ä¶j-1, definimos:</p>

<p>tij = {A : A -&gt; BC en P, y para algun k, 1 &lt;= k &lt; j, B en tik y C en ti+k,j-k}</p>

<p>Notar que tik y ti+k,j-k se computan antes. (Es un Floyd‚Äôs Algorithm de derivaciones!).</p>

<p>Complejidad para construir la tabla en cadena de n caracteres es n^3. Se hace como reconstruir un camino con el Floyd‚Äôs Algo.</p>

<p>(Pido gen(1, n, S) y en general gen(i, j, A) es A -&gt; wi si A -&gt; wi es una produccion, sino por cada k entre i, i+j pruebo si hay una prod A -&gt; BC tq B in ti,k, C in ti+k,j y devuelvo esa y llamo a ambos gen.)</p>

<h3 id="parsing-de-earley">Parsing de Earley</h3>

<p>Un item de Earley para G, w es [A -&gt; X1X2‚Ä¶Xk¬∑Xk+1‚Ä¶Xm, i] tq i entre 1‚Ä¶|w| y A -&gt; X1‚Ä¶Xm en P.</p>

<p>Construimos las listas de items l1‚Ä¶ln tq [A -&gt;  Œ±¬∑Œ≤, i] ‚àà j sii para alg√∫n Œ≥ y Œ¥ S</p>
<ul>
  <li>S =*&gt; Œ≥AŒ¥,</li>
  <li>Œ≥ =*&gt; a1 . . . ai</li>
  <li>Œ± =*&gt; ai+1 . . . aj</li>
</ul>

<p>Osea: el item [A -&gt;  Œ±¬∑Œ≤, i] en lj se lee ‚Äúpuedo generar hasta w[:i], luego una A, y Œ± genera w[i:j].</p>

<p>En particular si [A -&gt; Œ±., 0] est√° en lj, ganamos (w in L(G)).</p>

<p>El algoritmo de Earley genera las listas li. En 6 pasos.</p>

<ul>
  <li>Si S -&gt; Œ±, agregar [S -&gt; ¬∑Œ±, 0] a l0.</li>
  <li>Si [A -&gt; Œ± ¬∑ BŒ≤, 0] ‚àà l0 y [B ‚Üí Œ≥¬∑, 0] ‚àà l0 (en particular Œ≥ puede ser Œª) entonces agregar a l0, [A -&gt; Œ±B ¬∑ Œ≤, 0]. (Agrego no terminales que no aportan, adelantando el puntito).</li>
  <li>Si [A ‚Üí Œ±¬∑BŒ≤, 0] ‚àà l0, agregar a l0 para toda B ‚Üí Œ≥ en P, (si es que a√∫n no est√°), [B ‚Üí ¬∑Œ≥, 0]. (Clausura lambda!)</li>
  <li>Supongamos que ya hemos construido l0, . . . lj‚àí1. Si [B ‚Üí Œ±¬∑aBŒ≤, i] en lj‚àí1 tal que a = aj, agregar a lj [B -&gt; Œ±a ¬∑ Œ≤, i]. (adelantar el puntito trivial)</li>
  <li>Paso 5 Si [B -&gt; Œ± ¬∑ AŒ≤, k] ‚àà li y [A -&gt; Œ≥¬∑, i] ‚àà lj , agregar a lj [B ‚Üí Œ±A ¬∑ Œ≤, k]. (ahi sale el Floyd).</li>
  <li>Si [A ‚Üí Œ± ¬∑ BŒ≤, i] ‚àà lj , agregar a lj , para todo B ‚Üí Œ≥ en P, [B ‚Üí ¬∑Œ≥, j].</li>
</ul>

<p>Si la gramatica es no ambigua, la construcci√≥n de las listas es n^2 en tiempo, si n == |w|.</p>

<p>Luego, la derivaci√≥n mas a la derecha se encuentra en tiempo cuadratico, haciendo lookups en la tabla de listas (Hacemos R([A -&gt; X1‚Ä¶Xk., 0], n) partiendo de ln y vamos moviendo el puntero j a la izquierda si es un terminal, o hallando items tq forman substrings de w si no.</p>
<ul>
  <li>Encontrar un item [Xk -&gt; Œ≥¬∑, i‚Äô] en lj‚Äô para algun i‚Äô tq [A -&gt; X1‚Ä¶Xk-1 ¬∑ Xk‚Ä¶Xm, i] en li‚Äô. Luego ejecutar R([Xk -&gt; Œ≥¬∑, i‚Äô], j‚Äô). Luego k‚Äì, j‚Äô = i‚Äô.</li>
</ul>

<p>El algoritmo es cuadratico porque, a fin de cuentas, a lo sumo pasa una cantidad constante de veces por cada i‚Äô, j‚Äô (|P|*M donde M es m√°x size de RHS).</p>

<h2 id="dfa-afd-minimization">DFA (AFD) minimization</h2>
<p>Tengo un AFD y lo quiero convertir en uno equivalente que tenga el minimo numero de estados.</p>

<p>Primero removemos estados redundantes:</p>
<ul>
  <li>Removemos unreachable states (estados inalcanzables desde S).</li>
  <li>Removemos estados muertos (los que no pueden alcanzar un estado final bajo ninguna configuracion).</li>
  <li>Nondistinguishable states son los que no pueden distinguirse entre si para ningun input. Tambien son removibles.</li>
</ul>

<p>Normalmente armar al automata se hace en 2 pasos:</p>
<ul>
  <li>Remover redundantes</li>
  <li>Mergear indistinguibles</li>
</ul>

<p>El estado qi es inalcanzable si no existe w tq d(q0, w) = qi.</p>

<p>Los reachable salen facil: comenzas por q0 y, por cada estado en la frontera, por cada simbolo, agregas todos los adyacentes. Luego esos son tu frontera, los agregas a reachable y repetis. Luego los nuevos son la frontera, etc.</p>

<p>Dos estados p, q son indistinguibles si para toda cadena w, d(p, w) in F sii d(q, w) in F. Ademas si dos estados son indistinguibles, todos los alcanzables desde ellos tambien lo seran.</p>

<p>Para particionar los estados de un AFD por clase de distinguibilidad (y luego crear el AFD minimo) partimos con {F, ¬¨F} y hacemos</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for each X in P:
        for each e in X such that ¬¨marked(e): 
            X' = {e}
            for each e' in X:
                if [d(e',a)]==[d(e,a)] for every a in alphabet:
                    X' += {e'}
                    (mark(e'))
            X -= X';
            P+=X';
repeat until convergence;
</code></pre></div></div>
<h2 id="preguntas">Preguntas</h2>
<ul>
  <li>Algoritmo para ver si dos AFD reconocen el mismo lenguaje (o si un lenguaje regular es finito) ‚àö</li>
  <li>Ver que dada una gramatica con atributos puede crearse una con todos sus atributos sintetizados ~</li>
  <li>Ver que si tengo un automata de pila deterministico con ciclos, se puede generar uno que reconozca el mismo lenguaje sin ciclos ~</li>
  <li>Enunciar (no demostrar) pumping para lenguajes libres de contexto.</li>
  <li>repasar automata de pila no-det. cuantos posibles hay dado un alfabeto de simbolos?</li>
  <li>repasar estos: <a href="https://www.cubawiki.com.ar/index.php/Finales_Virtuales_Tleng:_Diciembre_de_2020">https://www.cubawiki.com.ar/index.php/Finales_Virtuales_Tleng:_Diciembre_de_2020</a></li>
</ul>

</div>
<a href='https://ko-fi.com/R6R3F4NIO' target='_blank' rel="noopener noreferrer nofollow">
  <img style='border:0px;height:4em;width:auto;' src='https://cdn.ko-fi.com/cdn/kofi5.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' loading='lazy'/></a>
  <p style='text-align: center;'>
  <a href="https://twitter.com/intent/tweet?text=Teor√≠a de Lenguajes - Notas para el final&url=https://strikingloo.github.io/wiki/tleng-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" title="Share on Twitter!">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em" rel="noopener noreferrer nofollow"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>Share on twitter]</a></p>

<template id="post-delayed-content">

<div class="backButton">
<a href="https://twitter.com/intent/tweet?text=Teor√≠a de Lenguajes - Notas para el final&url=https://strikingloo.github.io/wiki/tleng-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" id='tweetThis' title="Share on Twitter!" rel="noopener noreferrer nofollow">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>]</a>
<br/>
<a href="/blog/" id='backToBlog' title="Back to blog" rel="noopener noreferrer">[‚Üê]</a>
</div>
</template>
<script>

const headings = document.querySelectorAll('h2[id],h3[id]');
for (var heading of headings) {
    heading.innerHTML = `<a href=#${heading.id}>${heading.innerHTML}</a>`;
}
function externalLinks() { for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) { var b = c[a]; b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank") } }
externalLinks();

function renderBottomButtons(){
  const templateNode = document.getElementById('post-delayed-content')
  const templateContentClone = templateNode.content.cloneNode(true) // perform a deep copy
  document.body.appendChild(templateContentClone)
}

function scrollEventHandler(){
 const scrollOffset = window.pageYOffset
 const browserViewHeight = window.innerHeight
 if (scrollOffset > browserViewHeight/3) {
    console.log('done')
    renderBottomButtons();
    window.removeEventListener('scroll', scrollEventHandler)
 }
}
window.addEventListener('scroll', scrollEventHandler)
</script>

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@StrikingLoo" />
<meta name="twitter:title" content="Teor√≠a de Lenguajes - Notas para el final" />
<meta name="twitter:description" content="Notas para el final de Tleng. Basadas en las te√≥ricas de la materia, y adornadas luego al leer las preguntas tipicas de final. In Spanish." />

<meta name="twitter:image:src" content="https://strikingloo.github.io/resources/book-tw.jpg"/>
<meta property="og:image" content="https://strikingloo.github.io/resources/preview-image-terrarium.png"/>

			
			</div>
			<footer>
	    		<ul>
	        		<li><a href="mailto:lucianostrika44@gmail.com" rel="me" title="email me">‚úâÔ∏è</a></li>
	        		<li><a href="https://github.com/strikingloo" rel="me noopener noreferrer nofollow" title="GitHub"><svg viewBox="0 0 438.549 438.549" xmlns="http://www.w3.org/2000/svg" height="1em" width="1em"><path fill="#0F3D3E" d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289s4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136s11.704-.476 16.274-1.423c4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z"></path></svg></a></li>
			        <li><a href="https://twitter.com/intent/follow?screen_name=strikingloo" rel="me noopener noreferrer nofollow" title="twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg></a></li>
			        <li><a href="http://www.linkedin.com/in/luciano-strika" rel="me noopener noreferrer nofollow" title="linkedin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M72.16 99.73H9.927a5 5 0 00-5 5v199.928a5 5 0 005 5H72.16a5 5 0 005-5V104.73a5 5 0 00-5-5zM41.066.341C18.422.341 0 18.743 0 41.362 0 63.991 18.422 82.4 41.066 82.4c22.626 0 41.033-18.41 41.033-41.038C82.1 18.743 63.692.341 41.066.341zM230.454 94.761c-24.995 0-43.472 10.745-54.679 22.954V104.73a5 5 0 00-5-5h-59.599a5 5 0 00-5 5v199.928a5 5 0 005 5h62.097a5 5 0 005-5V205.74c0-33.333 9.054-46.319 32.29-46.319 25.306 0 27.317 20.818 27.317 48.034v97.204a5 5 0 005 5H305a5 5 0 005-5V194.995c0-49.565-9.451-100.234-79.546-100.234z"></path></svg></a></li>
			        <li><a href="/resources/Luciano_Strika.pdf">CV</a></li>
				</ul>
				<p><i>Built with ‚ù§Ô∏è by <a href="https://strikingloo.github.io/">Strikingloo</a>.</i></p>
			</footer>
			

			

			
			<link rel="preload" href="/css/non-critical-post-min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
			<noscript><link rel="stylesheet" href="/css/non-critical-post-min.css"></noscript>
        	
		</body>
	</html>
