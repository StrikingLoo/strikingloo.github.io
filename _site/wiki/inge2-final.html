<!DOCTYPE html>
	<html lang="en">
		<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23d8eaeb%22></rect><text x=%2250%%22 y=%2250%%22 dominant-baseline=%22central%22 text-anchor=%22middle%22 font-size=%2293%22>üå≥</text></svg>" />
            <title>Ingenieria del Software II - Notas para el final</title>
			<link rel="canonical" href="https://strikingloo.github.io/wiki/inge2-final">
			  <meta name="description" content="Notas para el final de Inge2. Basadas en los videos de la teorica. In Spanish.">
  			<meta property="og:site_name" content="Ingenieria del Software II - Notas para el final">

        	
        	<link rel="stylesheet" type="text/css" href="/css/post-min.css">
        	

			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52642322-5"></script>

			<script>
			  window.dataLayer = window.dataLayer || [];
			  function gtag(){dataLayer.push(arguments);}
			  gtag('js', new Date());

			  gtag('config', 'UA-52642322-5');
			</script>
			
			  <meta property="og:description" content="Notas para el final de Inge2. Basadas en los videos de la teorica. In Spanish.">
			
	  		<meta property="og:locale" content="en_US">
	  		
			  <meta property="og:title" content="Ingenieria del Software II - Notas para el final">
			  <meta property="og:type" content="article">
		  	  <meta property="article:published_time" content="2021-08-06T00:00:00-03:00">
		      <meta property="article:author" content="http://localhost:4000/">
		  	
		  	
  				<meta property="og:url" content="https://strikingloo.github.io/wiki/inge2-final">
  			
  			<meta content="index,follow" name="robots"><!-- All Search Engines -->
  			<meta content="index,follow" name="googlebot"><!-- Google Specific -->
  			<meta name="robots" content="max-image-preview:large">

		</head>
		<body>
			<div class="head-banner">
			<p>Strikingloo</p>
			<nav>
	    		<ul>
	        		<li><a href="/">Home</a></li>
		        	<li><a href="/about/">About</a></li>
	        		<li><a href="/wiki/">Wiki</a></li>
	        		<li><a href="/blog/">Blog </a></li>
	    		</ul>
			</nav>
			<div style="clear: both;"></div>
		    </div>

			<div class="container">
			
			<h1>Ingenieria del Software II - Notas para el final</h1>
<p class="meta">06 Aug 2021 - importance:  </p>




<div class="post">
  <h2 id="program-analysis">Program Analysis</h2>

<p><strong>Program Analysis</strong>: Discover useful facts about a program.</p>

<ul>
  <li>Dynammic : Execute a program and learn about it</li>
  <li>Static: compile-time</li>
</ul>

<p>Analysis can be complete (we find every useful fact) or sound (every fact we find is true). Typically static analysis is more complete, but dynammic analysis is more sound.</p>

<h2 id="iterative-analysis">Iterative analysis</h2>

<p>Armamos el control flow graph donde cada nodo es un statement y un nodo lleva a otro si puede precederlo. Vamos mappeando los valores posibles de variables si los sabemos, de nodo a nodo. Con eso podemos concluir, por ejemplo, si una variable siempre vale lo mismo en un cierto esstado.</p>

<p>El grafo usa statements del <em>while language</em> que es solamente un while; if ; y assignment. (con &amp;&amp; y !).</p>

<h3 id="chaotic-iteration">Chaotic iteration</h3>

<p>Iteramos los nodos del grafo en un orden aleatorio. Por cada nodo:</p>

<ul>
  <li>Out[n]¬†= intersection/union( x for x in IN[n] ) - kill(n) + gen(n).</li>
</ul>

<p>Elegir si intersection o union, y si out o in, te define 1 de 4 algoritmos. Repetimos hasta convergencia y entonces termina.</p>

<p>Siempre termina, pues los sets nunca se achican y hay un tama√±o m√°ximo finito.</p>

<p><strong>Very busy expressions</strong>: Out[n] = intersection(in[n‚Äô] for each n‚Äô in SUCC)  - kill(n) + gen(n) (mide expresiones que se usan en todos los sucesores! Y que en el medio ninguna variable que aparece en ella cambi√≥ de valor)</p>

<p><strong>Reaching definitions</strong> : Out[n] = union(in[n‚Äô] for each n‚Äô in PRE) - kill(n) + gen(n) (d√≥nde se hizo la ultima asignacion no overwritten?).</p>

<p><strong>Available Expressions</strong> : Out[n] = intersection(in[n‚Äô] for each n‚Äô in PRE) - kill(n) + gen(n) (expresiones que ya se computaron, y no se modificaron luego, en todos los caminos a este program point.)</p>

<p><strong>Live Variables Analysis</strong>: Out[n] = union(in[n‚Äô] for each n‚Äô in SUCC) - kill(n) + gen(n) (A variable is live if there is a path to a use of the variable that does not redefine the variable (the current value <em>might</em> be useful!) )</p>

<h2 id="pointer-analysis">Pointer Analysis</h2>

<p>Queremos trackear si dos pointers podrian o deberian aliasear entre ellos (el may-analysis suele ser mas interesante y comun que el must).</p>

<p>E.g., tengo v = new Color(); u = v; luego may-alias(u, v).</p>

<p>Para eso pasamos el programa en lenguaje while++ (le agregamos new, assignments, indexar con ., e indexar con [*]), removelos el control flow (todos los while, for e if se mueren) y con el nuevo grafo resultante, aun si es bastante primitivo, metemos flechas azules cuando var -&gt; cosa y rojas cuando cosa.attr = cosa‚Äô. 
Asignamos las flechas azules por <strong>allocation site</strong>, no solo por clase.</p>

<p>Por cada statement de while++-flow, siempre agregamos nodos y flechas, nunca removemos: por cada assignment e = new X(); agregamos flecha azul de e a X, donde hay un nodo X por cada allocation site. Por cada assignment v1 = v2; hacemos flechita de v1 a cada nodo tq v2-&gt; ese nodo.</p>

<p>Si el statement pinta v1.a = v2 entonces flechita roja de v1 a cada nodo tq v2 -&gt; nodo, con un label == a en la flechita.</p>

<p><strong>Flow abstraction</strong>: como abstraemos el flujo. Podemos ser flow-insensitive (remover todo el control de flujo) o flow-sensitive (dejarlo).</p>

<p><strong>Heap abstraction</strong>: Refiere a la granularidad de c√≥mo representamos los objetos para los que se aloca memoria y generan referencias. i.e., como particionamos un conjunto no acotado de objetos concretos a uno finito de objetos abstractos. Basicamente qu√© a√±adimos como nodo al grafo. Hay muchos sound schemes, podemos cambiar la precision y eficiencia.</p>

<ul>
  <li><strong>Allocation site based</strong>: cada allocation site (new X();) tiene un nodo propio. Finitely many abstract objects.</li>
  <li><strong>Type based</strong>: Menos granulado, menos costoso. Cantidad de tipos es finito, cantidad de objetos abstractos tambien. Al menos te dice el tipo de cada variable.</li>
  <li><strong>Heap insensitive</strong>: Un solo abstract object que es simplemente la heap. Todas las variables le apuntan con azul, y todos los atributos en rojo tambien.</li>
</ul>

<h3 id="modeling-aggregate-data-types-records">Modeling Aggregate Data Types: Records</h3>

<ul>
  <li><strong>Field Insensitive</strong>: merge all fields of each record.</li>
  <li><strong>Field based</strong>: merge each field for all records.</li>
  <li><strong>field sensitive</strong>: keep each field of each record object separate.</li>
</ul>

<h2 id="constraint-based-analysis">Constraint-Based analysis</h2>

<p>Nos deja separar implementacion del analisis, de declaracion de constraints (what de how) y abstraernos de la primera para concentrarnos en la segunda.</p>

<p>Puede ser interprocedural o intraprocedural. Ejemplo constraint language: datalog.</p>

<p>Es un lenguaje como prolog. Le pasas tu control-flow graph como un set de constraints por edges, le pasas como son las relaciones de kill y gen, y boom te genera analisis como live-variables o reaching definitions.</p>

<p>Tambien puede manejar may-alias analysis flow-independent si le pasas las reglas de qu√© hacer en los assignments, en los new y estas hecho.</p>

<h2 id="testing">Testing</h2>

<ul>
  <li>Tester != Developer (porque asi errores no coinciden tanto).</li>
  <li>Recursos finitos</li>
  <li>Especificaciones compartidas por tester y developer, ya que el tester las necesita para ver que el programa es consistente, y el developer para saber qu√© programar.</li>
</ul>

<p>Los approaches de testing caen en 4 categorias, como 4 cuadrantes en 2 ejes ortogonales: manual vs automatic y black- vs white-box.</p>

<p>Por ejemplo, manual y black box: no miro codigo y pruebo la UI de algo a mano clickeando todo.</p>

<p>Whitebox seria si miro el codigo y veo de cubrir todas las branches tocando botones a mano.</p>

<p>Automatico: Podriamos activar lugares al azar de la UI sucesivamente, sin mirar el codigo ni nada. O podriamos hacer un analisis estatico del codigo antes de automaticamente triggerear UI events, en cuyo caso esto es whitebox y automatico.</p>

<h3 id="automated-vs-manual-testing">Automated vs Manual testing</h3>

<p><strong>Automated</strong></p>
<ul>
  <li>Finds bugs more quickly</li>
  <li>No need to write tests (cheaper)</li>
  <li>Less maintenance cost when software changes</li>
</ul>

<p><strong>Manual</strong></p>
<ul>
  <li>Potentially better coverage</li>
  <li>Code less bloated</li>
</ul>

<p>Idealmente queremos combinar ambos.</p>

<h3 id="black-box-vs-white-box">Black-box vs White-box</h3>

<p><strong>Black-box</strong>: Basado en mirar inputs y outputs del programa.</p>
<ul>
  <li>Works for code that can‚Äôt be modified</li>
  <li>Code can be in any operable format</li>
</ul>

<p><strong>White-box</strong>: Basado en mirar el codigo fuente directamente.</p>
<ul>
  <li>Efficient</li>
  <li>Can have a much better coverage</li>
</ul>

<p>Usamos pre y post condiciones, idealmente escritos en el mismo lenguaje del codigo.</p>

<h3 id="testing-quality">Testing quality</h3>

<p><strong>Code Coverage</strong>: Can be measured in functions, statements, branches, lines and blocks. Pro: easy to measure. Con: doesn‚Äôt imply robustness.</p>

<p><strong>Mutation Analysis</strong>: Assumes the programmer wrote a close to right code. Tests variations of the program (e.g., replace x &lt; k with x &gt; k, or w + 1 to w - 1). If the testsuite is good, it should break on mutants. If it doesn‚Äôt, then we add a test that covers that case. As a possible problem: what happens when mutation generates equivalent programs?</p>

<h3 id="mutation-analysis">Mutation Analysis</h3>

<p>Tomo el codigo de una funcion y le aplico operadores de mutacion. Hacen un solo peque√±o cambio al codigo, e.g. cambiar un + por un -, una expr por abs(expr), o por 0, intercambiar argumentos de funcion, etc. Luego le corro el testsuite. Si rompe por los bugs introducidos en el cambio, decimos que ‚Äúla testsuite mata al mutante‚Äù, de lo contrario decimos que no. Llamamos el <strong>mutation score</strong> al % de mutantes que mueren sobre el total, para un total prefijado (y configuramos que mutaciones queremos usar, etc.).</p>

<p>Algunos mutantes pueden ser equivalentes: para todo input tienen el mismo output, aun si hay o no un defecto en su comportamiento.</p>

<p>Notar que hay muchisimos mutantes posibles para un solo programa peque√±o (aun para un solo statement). Algunas formas de resolver esto para ganar escalabilidad son: ejecutar para cada mutante, solo los inputs que tienen covertura de ese statement mutado. Mutacion debil: veo si modifique el valor de una variable del estado luego de mutar un statement, en vez de mirar si modifique el output mismo del programa.</p>

<h3 id="random-testing-fuzzing">Random Testing (Fuzzing)</h3>

<p><strong>Monkey Testing (for Android)</strong>: Generate a sequence of tapping events (down and up, or down, drag and up), then generate many different random sequences and check if any one sequence crashes the program.</p>

<p><strong>Concurrency testing</strong>: Simulate different thread schedules by adding artificial delays between threads, appending ‚ÄúSleep()‚Äù calls randomly on different threads‚Äô code. Shown to be a lot better than stress testing.</p>

<p>We call a bug‚Äôs ‚Äúdepth‚Äù the quantity of ordering constraints needed to guarantee the bug takes place. E.g., ‚Äústatement1 before statement 2 and statement 2 before statement 3‚Äù. These constraints imply scheduler behaviour, and transcend thread boundaries (inside a thread, two statements will always go in the same order, obv).</p>

<p>Cuzz and other frameworks say most bugs have small depth.</p>

<p>Pros: Can be a lot easier to use than manual testing, cheaper and more efficient. Con: uses more tests per coverage point and may find useless bugs (like weird unsanitized inputs). Also makes many tests that simply don‚Äôt pass preconditions.</p>

<blockquote>
  <p>Automatic testing should complement, not replace manual testing.</p>
</blockquote>

<p>Podemos usar alguna <a href="/wiki/tleng-final">gram√°tica formal</a> para generar inputs aleatorios que sean validos. De esta forma, especialmente en programas de mayor complejidad, los inputs generados tienen mas chances (idealmente 100%) de cumplir las precondiciones del programa a testear, siendo mucho mas eficiente la generacion de tests.</p>

<h2 id="automated-testing">Automated Testing</h2>

<p>A diferencia de Random testing, hacemos white-box testing y buscamos generar casos de test relevantes usando el codigo de forma directa.</p>

<p>Algunos ejemplos:</p>

<h3 id="korat">Korat</h3>

<p>Korat testea mayormente estructuras de datos algebraicas/linkeadas, enumerando para un cierto tama√±o n todos los posibles candidatos no isomorficos de ese tama√±o (e.g., toda lista linkeada de n nodos, o arbol binario de n nodos).</p>

<p>Enumera haciendo un vector de todos los fields de todos los nodos + una lista de valores posibles, y va ‚Äúexpandiendo‚Äù el vector en un orden dictado por una funcion ‚ÄúrepOK‚Äù que es el invariable de representacion de la estructura. Va a ir probando todos los valores posibles del vector (que univocamente describe una estructura) y viendo: si cumplen la precondicion los deja como test, sino no. Lo interesante es que prunea el espacio de valores posibles agresivamente, eliminando isomorfismos, y siguiendo un orden de stack con la precondicion: siempre expande el ultimo campo en ser accedido por repOK hasta que no quedan valores para expandirlo, y ahi el campo anterior, y asi.</p>

<p>Funciona mejor para estructuras de datos linkeadas, no para tipos dificiles de enumerar (e.g., enteros o floats).</p>

<h3 id="randoop">Randoop</h3>
<p>Feedback-directed random test generation.</p>

<p>Hace un test con muchas operaciones de seetup de estado (Crear un objeto, modificarlo etc.) y finalmente un assert de una propiedad que deberia holdearse (una post condicion de alguno de los metodos usados), e.g., o1.equals(o1).</p>

<p>Resuelve el problema de uniform random testing usando una secuencia: usa una secuencia de metodos, y si no rompen y no son ilegales los resultados, entonces la recuerda y luego puede extenderla llamando a otro metodo de la clase. Tiene que tener como input un budget de tiempo, y post-condiciones para los objetos testeados y sus metodos.</p>

<p>El output son contract-violating test-cases (method sequences). Estos casos no pueden romper ninguna precondicion ni lanzar excepciones en el camino, y cada uno tiene al final un assert que rompe.</p>

<p>Randoop algorithm:
<img src="img_inge2/randoop_algorithm.png" alt="" /></p>

<p>Luego de generar una secuencia, decide si la descarta, conserva y outputea como test, o la descarta por redundancia.</p>
<ul>
  <li>if preconditions broke (exception thrown before assert): <em>discard</em>.</li>
  <li>if preconditions worked but assertion broke: <em>output as failing test</em> (happy path).</li>
  <li>if preconditions worked but sequence redundant (simply do an equals between a generated object and any other object in the current generated universe): <em>discard</em>.</li>
  <li>if assertion passed but object not redundant: add to universe of generated objects.</li>
</ul>

<h3 id="greybox-fuzzing">Greybox Fuzzing</h3>

<p>Fuzzeo sin mirar el codigo, pero viendo la coverage. El algoritmo toma una serie de ‚Äúseeds‚Äù (inputs predefinidos) y mutaciones (operaciones que transforman las seeds y sus mutaciones).</p>

<p>Lo que hace el algoritmo es probar los path cubiertos por cada seed y, para los que no crashean ni vulneran precondiciones, los muta y genera nuevos inputs, y asi hasta K ejecuciones de inputs (K un budget provisto por el usuario).</p>

<p>Si un input aumenta la coverage, lo agregamos al set de seeds, para que pueda seguir mutando etc. En ‚Äúboosted‚Äù greybox fuzzing, cada input ser√° elegido como una siguiente seed con probabilidad proporcional a su ‚Äúenergia‚Äù que es 1/f(p(input)) donde f(p(x)) es ‚Äúcuantas veces un input recorrio este path en el codigo antes?‚Äù asi un input que recorre un path por primera vez tiene energia = 1, uno que recorre un camino visto 1000 veces tiene energia 1e-3, etc.</p>

<p>Defecto, propagacion, infeccion y falla (defecto es algo salio mal, propagacion es que afecto otras partes del programa, infeccion es que el defecto cambio un comportamiento y falla es que el programa efectivamente da un output distinto). (e.g., si mi programa es accidentalmente cuadratico, puede nunca fallar pero tiene un defecto por su mala performance. Lo mismo si indexo un puntero fuera de bounds pero no tengo segmentation fault porque justo estoy dentro de mi area.).</p>

<p>Basicamente, con blackbox fuzzing genero seed o seed+mutacion pero nunca agrego un mutante a mis seeds. Con greybox fuzzing voy agregando a mi corpus los mutantes efectivos, y tengo una metrica de efectividad con la que seleccionarlos.</p>

<h2 id="dynamic-symbolic-execution">Dynamic symbolic execution</h2>

<p>Tenemos <strong>symbolic execution</strong> desde los ‚Äô70s: por cada conjunto de ifs anidados, meto en un theorem prover todos, y si hallo un input que los cumpla, reporto que ese bloque de codigo es alcanzable. En particular si el bloque de codigo genera un error, asumimos que el error es posible.</p>

<p>Luego si el prover prueba que tal input no existe, ignoramos ese codigo aun si tiene fallas.</p>

<p>Pero si no somos capaces de probar existencia ni inexistencia, entonces erramos del lado de soundness: asumimos que hay un bug y reportamos que es alcanzable, aun si no sabemos como. Otro problema que tiene este algoritmo es que escala mal a codigo muy grande.</p>

<p>DSE comienza con un set de inputs aleatorio, y lo ejecuta. Luego backtrackea en el arbol de condiciones y toma un camino anteriormente no tomado, usando un theorem prover para hallar valores que cumplan todas las constraints. Genera el camino negando la ultima condicion que haya sido evaluada, luego backtrackeando.</p>

<p>Esto lo vuelve incomplete theorem prover: podria declarar insatisfactible una constraint satisfactible, pero nunca va a pensar que una insatisfactible tiene solucion.</p>

<p>Dynamic symbolic execution is akin to dynamic analysis itself: it is never reporting an error that no input can reach, and therefore it is complete. However it will be unsound, as it may fail to find inputs that trigger a certain failure.</p>

<h2 id="sbst-search-based-software-testing">SBST Search Based Software Testing</h2>

<p>Cuando las condiciones en los if son suficientemente complejas, usar un theorem prover para resolverlas puede ser lento o impracticable. En estos casos, recurrimos a algoritmos de hill climbing, <a href="/wiki/algo3-final">metaheur√≠sticas</a> o gen√©ticos para generar inputs que satisfagan una cierta condici√≥n.</p>

<p>Usan <strong>hill-climbing</strong>, <strong>algoritmos geneticos</strong> o <strong>metaheuristicas</strong>.</p>

<p>Como funcion de costo / fitness usamos una ‚Äúbranch distance‚Äù, que idealmente ser√° continua y derivable.</p>

<p>Como forma de mejorar branch distance podemos tener en cuenta dominators y post-dominators. Eventualmente guiamos nuestra busqueda con una mezcla del ‚Äúapproach level‚Äù (cuan cerca estoy del predicado, a cuantos if estoy) y la branch distance (la que definimos antes, cosas como ‚Äúa == b‚Äù seria abs(a-b).</p>

<p>Usamos una suma entre el ‚Äúapproach level‚Äù (cuandos nodos dependientes - ejecutados) y branch distance al predicado mas cercano (menos profundo), y tomamos la minima suma entre todos los path desde el root del cfg hasta el nodo que queremos alcanzar. Eventualmente es mejor sumar una normalizacion de la branch distance, para que no overwhelmee el approach level.</p>

<p>Se normaliza para que sea entre 0 y 1, pero no veo que usen un maximo, es mas v := v/(v+1)</p>

<h2 id="programacion-concurrente">Programacion concurrente</h2>

<p>3 niveles de concurrencia: concurrencia, paralelismo y distribucion.</p>

<p>Para modelar sistemas concurrentes usamos <strong>LTS (Labelled Transition Systems)</strong>: <a href="/wiki/tleng-final">automatas finitos deterministicos</a> tq hay n estados y entre dos estados la transici√≥n es un evento (el alfabeto es un set de eventos). Llamamos una ejecuci√≥n valida a toda cadena de eventos+estados resultantes que sea aceptada por el automata. Una traza, en cambio, es meramente la cadena de eventos pura aceptada.</p>

<p><strong>FSP (Finite Sequential Processes)</strong>: Nos deja describir un LTS a traves de una gramatica formal. e.g., CONTROLLER = INACTIVE; INACTIVE = (on -&gt; ACTIVE)|(burn -&gt; ONFIRE);&amp;c.</p>

<p>Para demostrar una propiedad de LTL, vamos a tomar el predicado P a demostrar, y crear A_{¬¨P} el automata que genera todas las trazas que no cumplen P. Luego hacemos interseccion entre este, y el automata correspondiente al programa (su LTS). Si da vac√≠o, es porque no hay instancia que no cumpla P. De no dar vac√≠o, nos genera nuestro contraejemplo.</p>

<p>Cada transici√≥n del FSP a√±ade un estado al LTS y una transicion de ese nuevo al source del referido. El FSP permite describir recursivamente procesos de finitos estados que aceptan cadenas infinitas de transiciones. En cada transicion puedo anotar los procesos (los no-terminales) o no, y ahi se deja implicito y anonimo (e.g., ON -&gt; (off -&gt; on -&gt; ON).</p>

<p>Si desde un estado tengo dos transiciones (x -&gt; A|x -&gt; B) tenemos que x es no deterministico. Si sale x, no deterministicamente elijo A o B.</p>

<p>Syntactic sugar: BUFF = (in[i:1..N]-&gt;out[i]-&gt;BUFF). (equivalente a (in[1]-&gt;out[1]-&gt;BUFF|in[2]‚Ä¶).</p>

<p>Also podemos count[i:0..N] = (when (i&lt;N) inc -&gt; COUNT[i+1])</p>

<p>Tenemos el estado magico <strong>Stop</strong> que es un estado sin salida.</p>

<p>Finalmente el operador || efectua una composici√≥n paralela: ||A = (B||C) A es la union de ambos B y C, y arranca en el start de ambos.</p>

<p>Podemos agregar acciones compartidas: acciones que figuran en mas de un LTS, y que solo pueden llamarse si estan disponibles en todos los LTS a la vez. Basicamente si una accion esta en el alfabeto de dos LTS, entonces bloquea a ambos a menos que ambos la tengan disponible (de lo contrario nadie puede tomarla).</p>

<p><strong>Strong bisimulation</strong>: Una relacion binaria R es bisimulacion fuerte sii para toda accion a, PRQ sii (P -&gt;a  P‚Äô) =&gt; existe Q‚Äô tq Q -&gt;a Q‚Äô y P‚ÄôRQ‚Äô, y analogo para el otro lado (Q, P).</p>

<p><strong>Strong bisimilarity</strong>: Dos LTS P, Q son bisimilares sii hay una bisimulacion fuerte R tq (P,Q) in R. Osea, cada uno puede simular al otro. Dos procesos son no bisimilares si existe un observador externo que puede distinguirlos. Se representa ‚ÄúQ simula a P‚Äù con P &lt;= Q.</p>

<p>Se agrega la nocion weak bisimulation: es igual pero incluye transiciones tau (como transiciones lambda) para trabajo interno de un proceso que no es input/output.</p>

<h3 id="logica-temporal">Logica Temporal</h3>

<p>Usamos la logica proposicional, mas dos operadores modales: [] y &lt;&gt;: uno para ‚Äúsiempre‚Äù y el otro para ‚Äúeventualmente‚Äù.</p>

<p>La logica temporal lineal usa estructuras de kripke y valuaciones que dan valores TorF a los mundos.</p>

<p>v |= []a sii para todo mundo w‚Äô tq vRw‚Äô pasa que w‚Äô|=a. !, &amp;&amp; y || se definen intuitivamente.</p>

<p>v |= &lt;&gt;a sii existe un mundo w‚Äô tq vRw‚Äô tq w‚Äô|=a.</p>

<p><strong>Logica Temporal</strong>: razona sobre el tiempo, adecuadas para un programa reactivo, caso particular de logica modal. Puede variarse de modelo de tiempo.</p>

<p>Una formula LTL debe interpretarse en una estructura de kripke (W, R) tq W numerable y R orden total de W.</p>

<p>Decimos que M |= P sii para toda traza s |= P.</p>

<p><strong>Safety</strong>: M |= []!(cosa mala)</p>

<p><strong>Liveness</strong>: M |= &lt;&gt;(cosa buena)</p>

<p>Los LTS no son estructuras de kripke, pero interpretamos una traza t como estructura de kripke, donde el conjunto de proposiciones es el alfabeto del LTS, p true en i sii p es la accion en posicion i de t.</p>

<p>Traza usa solo acciones observables.</p>

<p><strong>Automatas de Buchi</strong>: Reconocen cadenas infinitas, w-regulares tq tienen un estado de aceptacion y reconocen toda cadena que pase por ese estado infinitas veces.
Las cadenas que acepta estan en Sigma ^ Omega.</p>

<p>Podemos traducir una clausula a un automata de Buchi, cuyo tama√±o es exponencial en el tama√±o de la clausula a probar. El algoritmo a usar se llama ‚ÄúLTL2Buchi‚Äù.</p>

<p>Expandimos new a next, cuando new vacio miramos next+old si matchean y linkeamos. Hay regla para cada operador. Los Old definen las transiciones: solo te moves hacia un estado si tu config actual satisface toda clausula del OLD.</p>

<p>Arrancamos con un nodo con new = {P}, y despues por cada nodo que new!={}, expandimos el new. Los criterios de expansion son complejos, bizantinos y exceden el scope de este apunte.</p>

<p>Para probar P aplica a un LTS m, pasamos LTS a otro automata de b√ºchi usando LTS2Buchi (es una conversion muy directa: dejo todo casi igual y el conjunto F =Q).</p>

<p>Luego tomamos el producto entre el LTS2Buchi y el LTL2Buchi (Q = Q1xQ2, Q0 = Q01xQ02, F = F1xQ2 U Q1xF2 y los delta son un cartesiano de ambos filtrado por que ambas transiciones tengan sentido. El lenguaje del producto es la interseccion de los lenguajes. Basta con verificar su vacuidad para probar P (de lo contrario, probamos ¬¨P).</p>

<p>Para hallar que es no vacio, buscamos un ciclo que contenga un estado final y sea alcanzable desde S.</p>


</div>
<a href='https://ko-fi.com/R6R3F4NIO' target='_blank' rel="noopener noreferrer nofollow">
  <img style='border:0px;height:4em;width:auto;' src='https://cdn.ko-fi.com/cdn/kofi5.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' loading='lazy'/></a>
  <p style='text-align: center;'>
  <a href="https://twitter.com/intent/tweet?text=Ingenieria del Software II - Notas para el final&url=https://strikingloo.github.io/wiki/inge2-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" title="Share on Twitter!">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em" rel="noopener noreferrer nofollow"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>Share on twitter]</a></p>

<template id="post-delayed-content">

<div class="backButton">
<a href="https://twitter.com/intent/tweet?text=Ingenieria del Software II - Notas para el final&url=https://strikingloo.github.io/wiki/inge2-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" id='tweetThis' title="Share on Twitter!" rel="noopener noreferrer nofollow">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>]</a>
<br/>
<a href="/blog/" id='backToBlog' title="Back to blog" rel="noopener noreferrer">[‚Üê]</a>
</div>
</template>
<script>

const headings = document.querySelectorAll('h2[id],h3[id]');
for (var heading of headings) {
    heading.innerHTML = `<a href=#${heading.id}>${heading.innerHTML}</a>`;
}
function externalLinks() { for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) { var b = c[a]; b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank") } }
externalLinks();

function renderBottomButtons(){
  const templateNode = document.getElementById('post-delayed-content')
  const templateContentClone = templateNode.content.cloneNode(true) // perform a deep copy
  document.body.appendChild(templateContentClone)
}

function scrollEventHandler(){
 const scrollOffset = window.pageYOffset
 const browserViewHeight = window.innerHeight
 if (scrollOffset > browserViewHeight/3) {
    console.log('done')
    renderBottomButtons();
    window.removeEventListener('scroll', scrollEventHandler)
 }
}
window.addEventListener('scroll', scrollEventHandler)
</script>

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@StrikingLoo" />
<meta name="twitter:title" content="Ingenieria del Software II - Notas para el final" />
<meta name="twitter:description" content="Notas para el final de Inge2. Basadas en los videos de la teorica. In Spanish." />

<meta name="twitter:image:src" content="https://strikingloo.github.io/resources/book-tw.jpg"/>
<meta property="og:image" content="https://strikingloo.github.io/resources/preview-image-terrarium.png"/>

			
			</div>
			<footer>
	    		<ul>
	        		<li><a href="mailto:lucianostrika44@gmail.com" rel="me" title="email me">‚úâÔ∏è</a></li>
	        		<li><a href="https://github.com/strikingloo" rel="me noopener noreferrer nofollow" title="GitHub"><svg viewBox="0 0 438.549 438.549" xmlns="http://www.w3.org/2000/svg" height="1em" width="1em"><path fill="#0F3D3E" d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289s4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136s11.704-.476 16.274-1.423c4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z"></path></svg></a></li>
			        <li><a href="https://twitter.com/intent/follow?screen_name=strikingloo" rel="me noopener noreferrer nofollow" title="twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg></a></li>
			        <li><a href="http://www.linkedin.com/in/luciano-strika" rel="me noopener noreferrer nofollow" title="linkedin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M72.16 99.73H9.927a5 5 0 00-5 5v199.928a5 5 0 005 5H72.16a5 5 0 005-5V104.73a5 5 0 00-5-5zM41.066.341C18.422.341 0 18.743 0 41.362 0 63.991 18.422 82.4 41.066 82.4c22.626 0 41.033-18.41 41.033-41.038C82.1 18.743 63.692.341 41.066.341zM230.454 94.761c-24.995 0-43.472 10.745-54.679 22.954V104.73a5 5 0 00-5-5h-59.599a5 5 0 00-5 5v199.928a5 5 0 005 5h62.097a5 5 0 005-5V205.74c0-33.333 9.054-46.319 32.29-46.319 25.306 0 27.317 20.818 27.317 48.034v97.204a5 5 0 005 5H305a5 5 0 005-5V194.995c0-49.565-9.451-100.234-79.546-100.234z"></path></svg></a></li>
			        <li><a href="/resources/Luciano_Strika.pdf">CV</a></li>
				</ul>
				<p><i>Built with ‚ù§Ô∏è by <a href="https://strikingloo.github.io/">Strikingloo</a>.</i></p>
			</footer>
			

			

			
			<link rel="preload" href="/css/non-critical-post-min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
			<noscript><link rel="stylesheet" href="/css/non-critical-post-min.css"></noscript>
        	
		</body>
	</html>
