<!DOCTYPE html>
	<html lang="en">
		<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 rx=%2220%22 fill=%22%23d8eaeb%22></rect><text x=%2250%%22 y=%2250%%22 dominant-baseline=%22central%22 text-anchor=%22middle%22 font-size=%2293%22>üå≥</text></svg>" />
            <title>Bases de Datos - Notas para el final</title>
			<link rel="canonical" href="https://strikingloo.github.io/wiki/bases-de-datos-final">
			  <meta name="description" content="Notas para el final de Bases de Datos. Basadas en las diapos teoricas en el campus. In Spanish.">
  			<meta property="og:site_name" content="Bases de Datos - Notas para el final">

        	
        	<link rel="stylesheet" type="text/css" href="/css/post-min.css">
        	

			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52642322-5"></script>

			<script>
			  window.dataLayer = window.dataLayer || [];
			  function gtag(){dataLayer.push(arguments);}
			  gtag('js', new Date());

			  gtag('config', 'UA-52642322-5');
			</script>
			
			  <meta property="og:description" content="Notas para el final de Bases de Datos. Basadas en las diapos teoricas en el campus. In Spanish.">
			
	  		<meta property="og:locale" content="en_US">
	  		
			  <meta property="og:title" content="Bases de Datos - Notas para el final">
			  <meta property="og:type" content="article">
		  	  <meta property="article:published_time" content="2021-04-07T00:00:00+00:00">
		      <meta property="article:author" content="/">
		  	
		  	
  				<meta property="og:url" content="https://strikingloo.github.io/wiki/bases-de-datos-final">
  			
  			<meta content="index,follow" name="robots"><!-- All Search Engines -->
  			<meta content="index,follow" name="googlebot"><!-- Google Specific -->
  			<meta name="robots" content="max-image-preview:large">

		</head>
		<body>
			<div class="head-banner">
			<p>Strikingloo</p>
			<nav>
	    		<ul>
	        		<li><a href="/">Home</a></li>
		        	<li><a href="/about/">About</a></li>
	        		<li><a href="/wiki/">Wiki</a></li>
	        		<li><a href="/blog/">Blog </a></li>
	    		</ul>
			</nav>
			<div style="clear: both;"></div>
		    </div>

			<div class="container">
			
			<h1>Bases de Datos - Notas para el final</h1>
<p class="meta">07 Apr 2021 - importance:  </p>




<div class="post">
  <p><strong>Independencia fisica</strong>: Abstraccion entre los datos que ve el usuario, y su almacenamiento fisico -optimizaciones del DBMS etc-.</p>

<p><strong>Independencia l√≥gica</strong>: la capacidad del sistema de cambiar el esquema conceptual, sin cambiar la vista l√≥gica que el usuario tiene de los datos.</p>

<p><strong>DML vs DDL</strong>: DDL se usa para definir datos, e.g. CREATE, DROP, ALTER -agrega columnas-. DML se usa para manipular datos: no cambia el schema, solo cambia tuplas. DDL es horizontal, DML es vertical.</p>

<h3 id="mer--modelo-entidad-relacion">MER -Modelo Entidad Relacion</h3>

<p>Permite analizar requerimientos para generar un <strong>DER</strong> (Diagrama de Entidad-Relacion). 
Para dise√±ar:</p>
<ul>
  <li>Identifico entidades</li>
  <li>Identifico relaciones</li>
  <li>Identifico cardinalidades</li>
  <li>Busco las relaciones no binarias</li>
  <li>Miro atributos y claves</li>
</ul>

<h2 id="algebra-relacional">Algebra Relacional</h2>
<p>Lenguaje formal utilizado por el modelo relacional. Va de relaciones a relaciones haciendo operaciones -consultas-.
Fundamento formal del modelo relacional. Permite optimizar queries.</p>

<p>Operaciones:</p>

<p>Unarias: Select, project, rename.</p>

<p>Binarias: Union, intersection, minus. Solo pueden hacerse entre entidades union compatibles: con mismos tipos en mismo orden.</p>

<p>Joins: Producto cartesiano, join -inner, nunca joinnea nulls- , equijoin -inner con solo = como operacion-, natural join: inner join entre campos de mismo nombre y deja uno solo de cada duplicado. Si no tienen mismo nombre, hay que meter rename primero. Y los outer.</p>

<p>Llamamos <strong>selectividad del join</strong> a la cardinalidad del join / la del producto de las cardinalidades de la tabla.</p>

<p>Division: A \div B : Dame todas las tuplas de A tq matchean con toda tupla de B en los campos compartidos. Todo campo de B es campo de A, y se eliminan del resultado.</p>

<h2 id="calculo-relacional-de-tuplas">Calculo Relacional de Tuplas</h2>

<p>Otro lenguaje de consultas asociado al Modelo Relacional.
Lenguaje declarativo o descriptivo de las respuestas deseadas. 
Ej: { t | COND(t) }</p>
<ul>
  <li>t es tupla</li>
  <li>t unica variable libre de la expresion</li>
  <li>COND fbf de CRT</li>
</ul>

<p>Las formulas validas son t \in R, r.A op s.B y r.A op c (tq c constante).
op = { &lt;, &gt;, =, !=}</p>

<p>Llamamos a una <strong>expresion segura</strong> cuando garantiza devolver una cantidad finita de tuplas como resultado. Sino, es insegura.
Equivalentemente, una expresion es segura si todas las tuplas resultantes son parte del dominio de la expresion -todos los valores de atributos de todas las tuplas de las relaciones involucradas-.
Si nos restringimos a expresiones seguras, CRT es equivalente a AR.</p>

<p>Existen consultas que no pueden formularse ni siquiera en LPO. Por ejemplo tratar una tabla como grafo y pedir si existe camino de cualquier longitud entre dos ejes.</p>

<p>SQL se basa en CRT + operaciones aritmeticas, joins y un par mas de condimentos -stored procedures, etc.-.</p>

<h2 id="normalizacion">Normalizacion</h2>

<p>Tiene por objetivo <strong>preservar la informaci√≥n</strong>, pero <strong>minimizar la redundancia</strong>.
4 criterios de calidad de dise√±o:</p>
<ul>
  <li>La <strong>sem√°ntica de atributos clara</strong> en los esquemas.</li>
  <li>Las tuplas deben <strong>minimizar informaci√≥n redundante</strong>.</li>
  <li>La cantidad de <strong>valores NULL</strong> debe ser minimizada.</li>
  <li><strong>Tuplas esp√∫reas</strong> no deber√≠an poder ser generadas. -Natural join que genera cualquiera, como joinnear por pais-. Ocurre si hay campos compartidos entre dos tablas, pero no son FK ni PK de ninguna de las dos.</li>
</ul>

<p>Anomal√≠as de Actualizaci√≥n. Almacenar NATURAL JOINs introduce problemas adicionales.</p>
<ul>
  <li>Se complica si surge un elemento de una de las dos tablas que no tiene nada asociado en la otra -genera nulls, como minimo.</li>
  <li>Si tengo data redundante, mantener consistencia a mano es un pain, y actualizar en bulk es poco acertado.</li>
</ul>

<h3 id="dependencias-funcionales">Dependencias funcionales</h3>

<p>Decimos a -&gt; b si b depende de a - a define b-. Para un mismo valor de a, necesariamente b valdra lo mismo.</p>

<h3 id="fn-basadas-en-pk">FN basadas en PK</h3>
<p>Asumiendo que conocemos todas las DF de toda relacion, y cada relacion tiene una PK definida.</p>

<p>Haremos los tests de cada forma normal, y cada esquema que no pase algun test ser√° descompuesto en esquemas mas peque√±os que si lo pasen.
La forma normal de una relacion es la FN de nivel m√°s alto que ‚Äúaprueba‚Äù.
Ante cada descomposici√≥n, debemos garantizar: <strong>lossless join</strong> -joinear los componentes no genera tuplas espureas- y <strong>preservacion de DF</strong> -cada DF est√° representada en alg√∫n esquema resultante-. La primera es un must, la segunda un NTH.</p>

<p><strong>Superclave</strong>: conjunto de campos tq no hay dos tuplas distintas que sean iguales en todos ellos. Superset de una clave.</p>

<p><strong>Clave</strong>: conjunto de campos que es superclave y minimal -si no tuviera ese campo, pues no seria superclave-.</p>

<p><strong>Clave primaria</strong>: Designamos como PK a una de las claves candidatas, eligiendo de manera arbitraria.</p>

<p><strong>Atributo primo</strong>: un atributo que pertenece a al menos una CK de la tabla.</p>

<h3 id="formas-normales">Formas normales</h3>

<p><strong>FN1</strong>: Cada campo debe tener como dominio solo valores at√≥micos. En la tupla, toma uno solo de estos. Si tengo campos multivaluados, los muevo a una tabla nueva y hago que tengan como FK la PK de la anterior.</p>

<p><strong>FN2</strong>: Cada atributo no primo A de R <strong>depende funcionalmente de manera completa de la PK de R, y de toda CK</strong>. Osea, la PK de R es minimal, y abarca todos los otros campos minimalmente -no hay campos que dependan solo parcialmente de la PK-.</p>

<p><strong>3FN</strong>: Estar en 2FN y <strong>ningun atributo no primo de R depende transitivamente de la PK</strong>. E.g., empleado trabaja en depto #4 que se llama ‚Äúblah‚Äù. Si sabemos el numero de depto, sabemos el nombre, entonces depende solo transitivamente de la PK empleado.
Otra forma de verlo: para todo DF A -&gt; B se da que o bien A es CK o bien B es atributo primo de R.</p>

<p><strong>BCFN</strong>: Para toda dependencia funcional <em>no trivial</em> X -&gt; A de R, X es CK de R. <strong>Surrogate keys all the way down</strong>.</p>

<h3 id="clausura-de-dependencias">Clausura de dependencias</h3>

<p>Para hallar la clausura de F un cjto de DFs, tengo las reglas <strong>transitiva</strong>, <strong>reflexiva</strong> y la de <strong>incremento</strong> (a√±adir a la derecha un mismo elemento en ambos lados de la -&gt;).</p>

<p>Para un subcjto X de atributos de R, puedo hallar todos los atributos que dependen funcionalmente de X (X+) si voy dependencia por dependencia y, para cada dependencia A -&gt; B, X+=B si A \in X.</p>

<p>Para hallar clave de R:</p>
<ul>
  <li>K := R</li>
  <li>Por cada atributo A en K: si (K - A)+ es R entonces K-= A.
Al final tenemos una clave minimal.</li>
</ul>

<p>Para descomponer una entidad R en entidades FN3 SPI y SPDF:</p>
<ul>
  <li>Por cada dependencia X -&gt; Y en un conjunto DF minimal, creo una entidad XY a menos que haya creado otra que contenga XY.</li>
  <li>Si ninguna entidad contiene una clave de R, creo una entidad que tenga alguna clave de R como campos.</li>
</ul>

<p>Para descomponer en FNBC -SPI pero no SPDF-:</p>
<ul>
  <li>Por cada DF X -&gt; Y en el conjunto, creo una entidad XY y remuevo sucesivamente Y de R.</li>
</ul>

<h2 id="datos-no-estructurados">Datos No-estructurados</h2>

<p>Datos estructurados: Tienen un formato estricto, una estructura predefinida y fija.</p>

<p>Datos Semi-Estructurados: No tienen el mismo nivel de organizaci√≥n y predictibilidad que los datos estructurados. Los datos no residen en campos fijos o registros o tuplas, pero contienen elementos (marcas) que pueden separar los datos de manera jer√°rquica. Suelen representarse con JSON o XML y permiten modelar arboles de datos, etc. Punto medio entre estructurado -tablas de MR- y no-estructurado -un HTML pelado-.</p>

<h3 id="xml">XML</h3>

<p>Un formato parecido a HTML, pero extensible -los usuarios inventan sus propias tags-. Datos autodescriptivos -markup-, estructurados como √°rbol, con anidamiento, ademas de human-readable. 
XML is slower than JSON, because it is designed for a lot more than just data interchange.</p>

<p><strong>DTD</strong>: Una forma de definir schemas en XML -decir cuales son los campos, etc.-.</p>

<p><strong>XPath</strong>: El ‚Äúquery‚Äù language para XML. Te da los nodos que cumplen un cierto path, que puede tambien incluir ciertas restricciones.
E.g. : <code class="language-plaintext highlighter-rouge">/BARS/BAR/PRICE[@theBeer = ‚ÄùMiller‚Äù]</code>
Existe un actual query language para xml que estan estandarizando los de W3C: Xquery.</p>

<h2 id="transacciones">Transacciones</h2>

<p>Una transacci√≥n es un conjunto de instrucciones que se ejecutan formando una unidad l√≥gica de procesamiento. Una transaccion puede incluir uno o m√°s accesos a la BD.</p>

<p>Son necesarias para sistemas multiusuario: la base es accedida por mas de un usuario en concurrencia.</p>

<p>Podes marcarla con <code class="language-plaintext highlighter-rouge">begin transaction</code>, <code class="language-plaintext highlighter-rouge">end transaction</code> y puede o no ser read-only.</p>

<p>Un <strong>data item</strong> es lo que se bloquea en una transaccion, y su granularidad puede ser de registros, valores de atributo, o un bloque de disco. La operacion puede ser un read o un write, y pasa por un buffer de la DBMS. Interesante: la escritura puede verse diferida si el recovery-manager lo desea (see: logging).</p>

<p>El control de concurrencia es necesario porque de lo contrario, accesos concurrentes podrian generar estados incorrectos.</p>

<p>Algunos problemas posibles son: Lost update, Temporary Update (Dirty Read), Incorrect Summary Problem -le pegaste a una variable bien y otra aun no-, Unrepeatable Read Problem -leer el mismo atributo dos veces, una de las dos dirty-.</p>

<p>Una transaccion puede ser committed o aborted. En el segundo caso todas sus operaciones deben revertirse.</p>

<h3 id="acid-properties">ACID Properties</h3>

<p>ACID es un conjunto de propiedades de las bases de datos relacionales.</p>

<ul>
  <li><strong>Atomicity</strong> : Transacci√≥n como unidad at√≥mica. Las operaciones de una transacci√≥n se ejecutan en su totalidad o no se ejecuta ninguna.</li>
  <li><strong>Consistency preservation</strong>: Si la transaccion se ejecuta, mueve la base entre estados consistentes -segun reglas establecidas al definir cada entidad-.</li>
  <li><strong>Isolation</strong>: La ejecucion de una transacci√≥n no debe interferir en la de otra que se ejecute de manera concurrente. Cada transacci√≥n debe aparentar ser ejecutada como si lo hiciera en aislamiento.</li>
  <li><strong>Durability</strong>: Los cambios aplicados en la DB por una transaccion committeada, deben persistir en la BD. No pueden perderse por fallos.</li>
</ul>

<h3 id="componentes-del-dbms">Componentes del DBMS</h3>

<p>Scheduler: controla el orden en el que se ejecutan las transacciones.</p>

<p>Recovery Manager: es el encargado de asegurar la durabilidad y atomicidad de las transacciones.</p>

<h3 id="scheduling-de-transacciones">Scheduling de transacciones</h3>

<p>Definicion parcial de transacci√≥n: Conjunto de operaciones, parcialmente ordenado, que debe o bien terminar en commit o en abort, y especificar un orden para los read y write.</p>

<p><strong>Historia</strong>: orden en que se ejecuta un conjunto de transacciones. La unica restricci√≥n es que las operaciones de una misma transaccion deben respetar su orden parcial.</p>

<p><strong>Conflicto</strong>: si dos operaciones pertenecen a transacciones distintas, operan sobre un mismo item y al menos una de ellas es un write, tenemos conflicto.</p>

<h3 id="tipos-de-conflictos">Tipos de conflictos</h3>

<ul>
  <li><strong>Lost update</strong> ‚Äì dos transacciones intentan escribir el mismo item y el resultado de la primera se pierde porque se sobre escribe con el segundo antes de que se puedan grabar.</li>
  <li><strong>Phantom Read</strong> ‚Äì La transacci√≥n reejecuta la misma query pero el conjunto de tuplas resultados son distintos. Notar que hay tuplas nuevas o viejas. Es un caso dentro de non-repeatable read.</li>
  <li><strong>Dirty Read</strong> ‚Äì Una transacci√≥n lee un dato que NO ha sido committed.</li>
  <li><strong>Non-repeatable read</strong>: Leo un registro, alguien mas lo escribe, leo de nuevo. El dato committed me cambia el valor de alguna tupla.</li>
</ul>

<p>Podes ir subiendo el nivel de aislamiento de tu base de datos para evitar los lost updates, los dirty reads, non-repeatable reads y los phantom reads, en ese orden.</p>

<p>Una historia completa H sobre T conjunto de transacciones es un orden parcial &lt;H tq H es union de Ti, U&lt;i esta en U&lt;H y para todo par p, q de operaciones en conflicto, p&lt;q o q&lt;p estan en &lt;H.</p>

<p>Dos historias son equivalentes si est√°n definidas sobre el mismo conjunto de transacciones y contienen las mismas operaciones, ordenan las operaciones en conflicto de las transacciones no abortadas en el mismo orden.</p>

<p>Una historia es serializable, si existe una historia equivalente que es serial -corre primero toda uan transaccion, luego otra, etc.-. Esto es importante porque una historia serializable puede correrse mejorando la performance sin comprometer correctitud de las operaciones.</p>

<h3 id="grafo-de-seriabilidad">Grafo de seriabilidad</h3>

<p>Dada una historia H, construimos SG(H)</p>
<ul>
  <li>Agrego un nodo por transaccion</li>
  <li>Agrego un arco de Ti a Tj si hay una operacion en conflicto y Ti ocurre antes que Tj</li>
</ul>

<p>Una historia sera serializable si SG(H) es aciclico.</p>

<h3 id="tipos-de-historias">Tipos de Historias</h3>

<p>Decimos Ti lee X de Tj si Tj fue la ultima en escribir X antes que Ti leyera, y no abort√≥.
Luego los tipos de historias son:</p>
<ul>
  <li><strong>Recuperable</strong> (RC): Si cuando Ti lee de Tj en H, si ci \in H, cj &lt; ci. (Si leo de j, j committeo antes que yo si committee).</li>
  <li><strong>Evita abort en Cascada</strong> (ACA): Ti lee de Tj en H, entonces cj &lt; ri(x). (Si leo de j, j committeo <em>antes de que leyera</em>).</li>
  <li><strong>Estricta</strong> (ST): si wj(x) &lt; oi(x), o bien aj &lt; oi(x) o cj &lt; oi(x), oi(x) \in {wi(x), ri(x)}. (si <em>leo o escribo</em> algo que toc√≥ j, j tiene que ya haber terminado -por abort o por commit-).</li>
</ul>

<p>Alivorte, ST: si la operacion de escritura de Ti precede a una operacion conflictiva de Tj otra transaccion, entonces el commit o abort de Ti tambien debe precederla. Es como tratar cada registro como un mutex, y los commit/abort son unlocks.</p>

<p>ACA: Si una Ti va a realizar un read, tiene que esperar hasta que toda transaccion que escribe antes haga un commit.</p>

<p>Recuperable: si Ti hace un read dirty, no puede committear hasta que la otra haya committeado.</p>

<h3 id="control-de-concurrencia">Control de concurrencia</h3>

<p><strong>Lock binario</strong>: lockeo cada registro con un lock -un mutex- que bloquea tanto read como write. Hasta que no hay Ui(x) no puede haber otro Li(x).</p>

<p><strong>Lock multiple -compartido-</strong>: puedo hacer un wLi(x) o un rLi(x). La primera evita reads y writes posteriores hasta el unlock, pero la segunda sigue permitiendo los reads.</p>

<p><strong>2PL</strong>: Cada transaccion debe hacer su ultimo lock antes de su primer unlock. Si esto se cumple, el scheduler puede patear cada operacion que genere conflicto, y no liberarla hasta que el lock correspondiente se libera.</p>

<p>Se llama two-phase porque hay una fase de ‚Äúcrecimiento‚Äù en la que las transacciones adquieren locks, y una de decrecimiento en la que los pierden. Puede generar deadlocks, pero se hace un wait-for graph y, si hay un ciclo implica deadlock.
Pero 2PL garantiza seriabilidad! Aun si no previene deadlocks o rollbacks en cascada.</p>

<p>Ademas, existe 2PL ST que es igual pero solo unlockea los de escritura luego de committear o abortar, y 2PL Riguroso que no libera ningun lock hasta no haber committeado.</p>

<p><strong>Timestamp-based</strong>: Cada transaccion tiene una timestamp TS(Ti). Cuando leo, si el registro se escribio despues entonces me abortan. Si se escribio antes, leo si ya esta committeado, sino espero. Cuando escribo, si el registro se ley√≥ despues, me abortan. Si se escribio despues, pero no se leyo, pueden ignorarme -regla de Thomas- o no. En caso de leer, ademas espero hasta que se committeo la ultima transaccion en escribir.</p>

<p>Cuando una operacion es imposible, decimos que no es <strong>f√≠sicamente realizable</strong>.</p>

<p>Esto asegura seriabilidad tambien.</p>

<p><strong>Multiversion</strong>: Guardo todas las versiones de un registro que sepa que alguien puede usar -todas las escrituras posteriores a la version mas vieja por timestamp.</p>

<h2 id="no-sql-databases">NO-SQL Databases</h2>

<p>Dise√±adas tomando en cuenta la existencia de datos no estructurados (o semi estructurados).</p>

<p>No relacionales, open-source, distribuidas, escalan muy bien horizontalmente.</p>

<ul>
  <li>No tienen schema</li>
  <li>Sencillas de replicar</li>
  <li>Interfaz sencilla</li>
  <li>Almacenan grandes volumenes de datos</li>
  <li>Son BASE en vez de ACID</li>
</ul>

<h3 id="base">BASE</h3>

<p>Base significa que dan <strong>Basic Availability</strong> (availability as in CAP-theorem), <strong>Soft state</strong> (el estado va mutando aun sin intervenci√≥n externa, debido a la consistencia eventual) y <strong>Eventual consistency</strong> (El sistema va a ser consistente a lo largo del tiempo, si no recibe inputs en el medio).</p>

<p>Osea que, si el sistema se lo deja quieto, su estado va a ir mutando hacia una consistencia, que garantiza, y en todo momento va a devolver respuestas no-errores, aunque quizas no sean el dato mas reciente.</p>

<p>Enfasis en fault-tolerance distribuido y redundancia. Muchos discos distintos con mucha replicacion.</p>

<p>No hay garantia de consistencia como la de ACID, pero si a que eventualmente va a haber un unico estado, si se deja al sistema quieto. No hay garantias de una deadline.</p>

<p>Partition tolerance: el sistema sigue andando aun si se cae un nodo.</p>

<h3 id="key-value-store">Key-Value Store</h3>

<p>Son la base que mas escala. Almacenan items como ciudadano de primer orden, en un sistema de pares key, value, donde un item puede ser de muchos tipos ricos -texto plano, XML, JSON, imagenes- y sin ningun schema. Pueden guardarse en ‚Äúdominios‚Äù como semi-estructura.</p>

<p>Puede tener redundancia y no tener integridad referencial. Escalan muy bien y funcionan bien con object-oriented design.</p>

<p>Son buenos almacenando datos, pero si se quiere analizarlos conviene primero transferirlos a una base relacional u otro formato.</p>

<p>Al no haber estructura, la integridad de datos queda como ejercicio para el programador.</p>

<h3 id="document-oriented-databases">Document-oriented Databases</h3>

<p>Son menos libres que los kvs, pero a cambio tienen datos mas claros. Cada valor <strong>debe</strong> ser un XML o JSON -un documento-, pero pueden diferir en estructura y datos. Vuelve el concepto de metadata, y eso permite indexar algunos campos, u otras optimizaciones.</p>

<h3 id="column-family-databases">Column Family Databases</h3>

<p>Columnas de datos relacionados. Un grupo de columnas tiene una funcion similar a una tabla en una base relacional. Las ‚Äúcolumn families‚Äù son columnas que se acceden y almacenan juntas. Una column family es un par clave, valor, donde la clave es el nombre de la family, y el valor es el conjunto de columnas agrupadas. Pueden repetirse.</p>

<p>Termina siendo como si una key mappeara a un json, en un kvs, pero con un poco mas de schema -los jsons tienen todos mas o menos los mismos campos- y con redundancia y particiones.</p>

<p>Escalan muy bien y soportan datos semi estructurados, con indices, pero no tienen consistencia inmediata ni datos relacionales.</p>

<h2 id="optimizacion-de-consultas">Optimizacion de consultas</h2>

<p>El <strong>Procesamiento de consultas</strong> permite la extracci√≥n de datos desde un lenguaje de consulta. Los pasos son <strong>Parsear y traducir</strong>, <strong>optimizar</strong>, <strong>Generar el codigo en instrucciones</strong> y <strong>ejecutar la consulta</strong>.</p>

<p>El optimizador de consultas genera varios <strong>planes de ejecuci√≥n</strong> para la consulta, evalua los costos y se queda con el mas eficiente.</p>

<p>El procesador de consultas toma la consulta y la ejecuta segun el plan, para devolver el resultado.</p>

<p>El optimizador busca generar el plan de ejecuci√≥n m√°s eficiente, tipicamente en cantidad de accesos a disco.</p>

<p>Una query sin agregaciones termina siendo una sucesion de productos cartesianos, un filtro por las condiciones del where, y una proyeccion de las columnas pedidas.</p>

<h3 id="indices">Indices</h3>

<p>Pueden ser <strong>Clustered o non-clustered</strong>: Clustered significa que el archivo en el que estan almacenados los registros est√° ordenado por este campo. Non-clustered si no. Osea, los datos del archivo estan fisicamente ordenados por ese campo.</p>

<p><strong>Denso o no denso</strong>: Tiene todos los valores, o solo algunos.</p>

<p><strong>Primario o secundario</strong>: Primario es que tiene le registro entero, secundario es que tiene un nivel de indirecci√≥n: solo tiene el rid como value.</p>

<p>B+ Clustered Tree : <strong>Repasar!</strong>
Static Hash: Un hashtable con cantidad fija de buckets, donde cada entry apunta a una lista encadenada de bloques. Muy buenos para buscar por igualdad o desigualdad.</p>

<h3 id="algoritmos-para-operaciones">Algoritmos para operaciones</h3>

<p>Cada operacion de AR tiene distintos algoritmos para ejecutarla -operadores fisicos-. 
<strong>Pipeline</strong>: Se le pasan los resultados de la primera operacion a la segunda en streaming a medida que se generan, evitando almacenarlos en el medio y acelerando el proceso.</p>

<p>Los filtros, los productos cartesianos/joins y la union e interseccion son todos conmutables.</p>

<h2 id="logging">Logging</h2>

<p>El DBMS necesita un modulo de recovery que administre situaciones de recuperacion de datos ante una falla.</p>

<h3 id="tipos-de-errores">Tipos de errores</h3>

<ul>
  <li><strong>Fallas en las transacciones:</strong> Pueden ser <strong>Errores L√≥gicos</strong> (la transacci√≥n no se completa porque ocurre un error interno como romper una restriccion) o <strong>Errores de estado interno</strong> (el DBMS termina la transaccion por abort, deadlock, etc.).</li>
  <li><strong>Fallas de Sistemas</strong>: Fallas de SW (bugs en el DBMS), fallas de HW (crash recuperable de la computadora).</li>
  <li><strong>Fallas de almacenamiento</strong>: Son irrecuperables, se resuelven solo con backup and restore, y redundancia.</li>
</ul>

<h3 id="recuperacion">Recuperacion</h3>

<p>Los algoritmos de recovery tienen dos partes: acciones que se ejecutan <strong>mientras la transacci√≥n est√° ocurriendo</strong> para garantizar la recuperabilidad ante una falla. Y acciones que se llevan a cabo <strong>una vez que una falla sucede.</strong></p>

<p>El DBMS tiene un cache manager que hace fetch y flush como esperarias, con bits de dirty y present.</p>

<p>El Recovery Manager (RM) tiene una interfaz simple: writes que toman Ti, Ri y v/w -segun si redo o undo, guardar valor nuevo o viejo-, commit y abort, y un restart que recupera ante crash.</p>

<p>El RM puede ser <strong>Undo</strong> -escribe a disco cada write, y los deshace si la transaccion aborta-, o <strong>redo</strong> -loggea cada cambio y, ante un commit, lo pasa al disco-.</p>

<p>Todas las operaciones, commits y aborts se registran en el log, para luego poder restaurar. Se mantiene en memoria -log buffer- y cada tanto se persiste en un archivo. En cada commit, o en group commit policy -agrupa varios commits antes de flushear-.</p>

<p><strong>Undo rule</strong>: Si el disco tiene el ultimo valor committeado de X antes de reemplazarlo con uno nuevo, preservarlo en el log.</p>

<p><strong>Redo rule</strong>: Si una Ti committea, persistir los cambios en el disco.</p>

<p><strong>Garbage Collection</strong>: [Ti, x, v] puede eliminarse si Ti abort√≥, o si Ti committeo y alguien mas ya soreescribio.</p>

<p><strong>Undo/Redo</strong>: Es el mas complicado. El write guarda la Ti en una lista de activas, y escribe [Ti, x, v_old, v_new] en el log, pero pone el valor v en la cache-entry de x -fetcheando primero si no estaba-. El read solo lee de la cache y fetchea si missea. El commit mueve Ti de activas a committeadas, y loggea el commit. En el abort, se va cargando en la cache el valor de cada x de antes de la Ti.</p>

<p>Ante un restart: por cada entry del log, si x no se habia visto antes, se le asigna un slot en el cache. Si Ti estaba committeada, copiar v en el slot alocado para x y mover x a ‚Äúredone‚Äù -un empty set-. Sino, copiar la imagen anterior de x en el slot de x en cache, y mover x a undone. Si Ti es committeada, removerla de activas.</p>

<p><strong>Repasar esto!!</strong></p>

<p><strong>Checkpoints</strong>: Un checkpoint agrega la entry &lt;checkpoint&gt; y hace flush del log a disco. Escribe todos los datos dirty committeados sin persistir. Luego en un crash podemos ignorar toda transaccion committeada antes del  ultimo checkpoint. Decimos que un checkpoint es quiescente si bloquea las transacciones.</p>

<hr />

<h2 id="long-duration-transactions">Long Duration Transactions</h2>

<p>Una LDT puede ser:</p>
<ul>
  <li>Transaccion que escribe/modifica <strong>muchos registros</strong> en el orden de millones+</li>
  <li>Un <strong>Workflow que conecta diferentes bases</strong> e.g., por redes.</li>
</ul>

<p>Para ejecutar una SDT creamos una ‚Äúsaga‚Äù que es un grafo de acciones, donde cada una bloquea a la siguiente, asociada cada una a una ‚Äúcompensacion‚Äù que es su accion inversa. Si quiero revertir una saga ejecutada -un path del grafo- hago el path a la inversa ejecutando las compensaciones.</p>

<h3 id="in-memory-databases">In-memory databases</h3>

<p>Almaceno todo en memoria sin bajarlo a disco. Puedo tener o no persistencia. Si la tengo, es a traves de un transaction log, lo unico que escribo. Si quiero restaurar la base desde disco solo tengo que ejecutar el log de nuevo. Pueden ser por rows o columnares.</p>

<h3 id="distributed-databases">Distributed Databases</h3>

<p>Colecciones de bases de datos, distribuidas en una red de computadoras, potencialmente heterogenea.
Nos empieza a importar el <strong>costo de transferencia</strong> de un conjunto de rows a la hora de optimizar operaciones.</p>

<p>Se abstrae al usuario de muchas complejidades de la arquitectura de la base. I.e., transparencia de:</p>
<ul>
  <li><strong>Organizacion de los datos</strong>: Tenemos transparencia de ubicacion y nombres: el usuario no sabe donde guardamos cada cosa.</li>
  <li><strong>Fragmentacion</strong>: Hay sharding horizontal -subdividir en rows- y vertical -por columnas-, y esto le es transparente al usuario.</li>
  <li><strong>Replicacion</strong>: redundancia para fault-tolerance.</li>
  <li><strong>Otros</strong>: tiene que ver con optimizaciones y ejecucion.</li>
</ul>

<p>Algunas propiedades deseables: Disponibilidad -uptime-, escalabilidad -horizontal o vertical-, partition tolerance, autonomia -de nodos individuales-</p>

<p>Datos y Software distribu√≠dos en multiples lugares, pero conectados a trav√©s de una red de comunicaciones.
<strong>Grado de Homogeneidad</strong> : Si todos los servers y usuarios utilizan el mismo software.</p>

<h2 id="integracion-de-datos">Integracion de datos</h2>

<p>Integracion de datos vs transferencia. En una tenes alguna interfaz transparente para hacer consultas que agrega datosde multiples fuentes (BDs distintas, web, no estructurados, etc.). En la otra transferis datos de una base a otra que son de una misma naturaleza y estructuras homomorficas. Podes usar mappeos de schemas, que se hacen a menudo con ‚ÄúSource target tuple generating dependencies‚Äù: triggers que mappean un campo de una tabla a otro de la otra (so.scoring -&gt; pay.payment_id).</p>


</div>
<a href='https://ko-fi.com/R6R3F4NIO' target='_blank' rel="noopener noreferrer nofollow">
  <img style='border:0px;height:4em;width:auto;' src='https://cdn.ko-fi.com/cdn/kofi5.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' loading='lazy'/></a>
  <p style='text-align: center;'>
  <a href="https://twitter.com/intent/tweet?text=Bases de Datos - Notas para el final&url=https://strikingloo.github.io/wiki/bases-de-datos-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" title="Share on Twitter!">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em" rel="noopener noreferrer nofollow"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>Share on twitter]</a></p>

<template id="post-delayed-content">

<div class="backButton">
<a href="https://twitter.com/intent/tweet?text=Bases de Datos - Notas para el final&url=https://strikingloo.github.io/wiki/bases-de-datos-final%2F%3Futm_source%3Dtwitter%26utm_medium%3Dsocial&via=strikingLoo" id='tweetThis' title="Share on Twitter!" rel="noopener noreferrer nofollow">[<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#1DA1F2" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg>]</a>
<br/>
<a href="/blog/" id='backToBlog' title="Back to blog" rel="noopener noreferrer">[‚Üê]</a>
</div>
</template>
<script>
const headings = document.querySelectorAll('h2[id],h3[id]');
for (var heading of headings) {
    heading.innerHTML = `<a href=#${heading.id}>${heading.innerHTML}</a>`;
}
function externalLinks() { for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) { var b = c[a]; b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank") } }
externalLinks();

function renderBottomButtons(){
  const templateNode = document.getElementById('post-delayed-content')
  const templateContentClone = templateNode.content.cloneNode(true) // perform a deep copy
  document.body.appendChild(templateContentClone)
}

function scrollEventHandler(){
 const scrollOffset = window.pageYOffset
 const browserViewHeight = window.innerHeight
 if (scrollOffset > browserViewHeight/3) {
    console.log('done')
    renderBottomButtons();
    window.removeEventListener('scroll', scrollEventHandler)
 }
}
window.addEventListener('scroll', scrollEventHandler)
</script>

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@StrikingLoo" />
<meta name="twitter:title" content="Bases de Datos - Notas para el final" />
<meta name="twitter:description" content="Notas para el final de Bases de Datos. Basadas en las diapos teoricas en el campus. In Spanish." />

<meta name="twitter:image:src" content="https://strikingloo.github.io/resources/book-tw.jpg"/>
<meta property="og:image" content="https://strikingloo.github.io/resources/preview-image-terrarium.png"/>

			
			</div>
			<footer>
	    		<ul>
	        		<li><a href="mailto:lucianostrika44@gmail.com" rel="me" title="email me">‚úâÔ∏è</a></li>
	        		<li><a href="https://github.com/strikingloo" rel="me noopener noreferrer nofollow" title="GitHub"><svg viewBox="0 0 438.549 438.549" xmlns="http://www.w3.org/2000/svg" height="1em" width="1em"><path fill="#0F3D3E" d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289s4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136s11.704-.476 16.274-1.423c4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z"></path></svg></a></li>
			        <li><a href="https://twitter.com/intent/follow?screen_name=strikingloo" rel="me noopener noreferrer nofollow" title="twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M302.973 57.388a117.512 117.512 0 01-14.993 5.463 66.276 66.276 0 0013.494-23.73 5 5 0 00-7.313-5.824 117.994 117.994 0 01-34.878 13.783c-12.381-12.098-29.197-18.983-46.581-18.983-36.695 0-66.549 29.853-66.549 66.547 0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204a5.001 5.001 0 00-8.196.642c-5.896 10.117-9.013 21.688-9.013 33.461 0 16.035 5.725 31.249 15.838 43.137a56.37 56.37 0 01-8.907-3.977 5 5 0 00-7.427 4.257c-.007.295-.007.59-.007.889 0 23.935 12.882 45.484 32.577 57.229a57.372 57.372 0 01-5.063-.735 4.998 4.998 0 00-5.699 6.437c7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961a120.4 120.4 0 01-14.095-.826 5 5 0 00-3.286 9.174c29.023 18.609 62.582 28.445 97.047 28.445 67.754 0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367 0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536a5 5 0 00-6.182-7.351z"></path></svg></a></li>
			        <li><a href="http://www.linkedin.com/in/luciano-strika" rel="me noopener noreferrer nofollow" title="linkedin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310" height="1em" width="1em"><path fill="#0F3D3E" d="M72.16 99.73H9.927a5 5 0 00-5 5v199.928a5 5 0 005 5H72.16a5 5 0 005-5V104.73a5 5 0 00-5-5zM41.066.341C18.422.341 0 18.743 0 41.362 0 63.991 18.422 82.4 41.066 82.4c22.626 0 41.033-18.41 41.033-41.038C82.1 18.743 63.692.341 41.066.341zM230.454 94.761c-24.995 0-43.472 10.745-54.679 22.954V104.73a5 5 0 00-5-5h-59.599a5 5 0 00-5 5v199.928a5 5 0 005 5h62.097a5 5 0 005-5V205.74c0-33.333 9.054-46.319 32.29-46.319 25.306 0 27.317 20.818 27.317 48.034v97.204a5 5 0 005 5H305a5 5 0 005-5V194.995c0-49.565-9.451-100.234-79.546-100.234z"></path></svg></a></li>
			        <li><a href="/resources/Luciano_Strika.pdf">CV</a></li>
				</ul>
				<p><i>Built with ‚ù§Ô∏è by <a href="https://strikingloo.github.io/">Strikingloo</a>.</i></p>
			</footer>
			

			

			
			<link rel="preload" href="/css/non-critical-post-min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
			<noscript><link rel="stylesheet" href="/css/non-critical-post-min.css"></noscript>
        	
		</body>
	</html>
